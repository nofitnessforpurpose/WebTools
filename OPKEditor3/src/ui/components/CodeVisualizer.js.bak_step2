'use strict';

/**
 * CodeVisualizer.js
 * -----------------
 * Visualizes the structure and dependencies of OPL code.
 * 
 * Features:
 * 1. System Map: Shows all packs, procedures, and globals.
 * 2. Detailed Cards: Procedures show Parameters and Local Variables in inner containers.
 * 3. Orthogonal Routing: Links use Manhattan layout with rounded corners.
 * 4. Collapsible Containers: Packs, Inner Logic, and Procedures can be minimized.
 * 5. Floating Nodes: Layout recalculates on collapse/expand.
 * 6. Code Editor: Uses the application's native CodeEditor component.
 * 7. Styling: Rounded corners for all containers (SVG attributes), robust ThemeManager integration.
 */
var CodeVisualizer = window.CodeVisualizer = (function () {


    // --- Data Extraction ---

    function extractSystemData(packs) {

        var globalProcMap = {}; // procedureName -> { paramCount }

        var system = {
            packs: [],
            nodes: {}, // Map of name -> { type, packIndex, ... }
            links: []  // Array of { from, to, type, label }
        };

        if (!packs || packs.length === 0) return system;

        // 1. First Pass: Identify all Procedures and Globals (Nodes)
        packs.forEach(function (pack, pIdx) {
            var packData = {
                name: pack.filename || "Pack " + (pIdx + 1),
                index: pIdx,
                procedures: [],

                globals: [],
                dataFiles: [], // Names of Data Files
                fileIdMap: {}  // ID -> Name Mapping
            };

            // Pre-scan for Data Files to map IDs
            pack.items.forEach(function (item) {
                if (!item.deleted && item.type === 1) {
                    var fileId = item.data[10] & 0x7f;
                    packData.fileIdMap[fileId] = item.name.toUpperCase();
                }
            });

            // 2. Data Files Pass (Create Parents First)
            pack.items.forEach(function (item) {
                if (item.deleted) return;
                if (item.type === 1) {
                    var nodeName = item.name.toUpperCase();
                    system.nodes[nodeName] = {
                        type: 'DATA_FILE',
                        packIndex: pIdx,
                        name: item.name,
                        label: item.name,
                        id: item.data[10] & 0x7f,
                        records: [],
                        degree: 0
                    };
                    packData.dataFiles.push(item.name);
                }
            });

            // 3. Records Pass (Link to Parents)
            pack.items.forEach(function (item, idx) {
                if (item.deleted) return;
                // Data Records (Type matches File ID)
                if (packData.fileIdMap[item.type]) {
                    var parentName = packData.fileIdMap[item.type];
                    var uniqueId = item.name.toUpperCase() + "_REC_" + idx;

                    if (!system.nodes[uniqueId]) {
                        system.nodes[uniqueId] = {
                            type: 'DATA_RECORD',
                            packIndex: pIdx,
                            name: item.name,
                            label: item.name,
                            parent: parentName,
                            degree: 0
                        };

                        // Link to Parent (Guaranteed to exist if file is present)
                        if (system.nodes[parentName]) {
                            system.nodes[parentName].records.push(uniqueId);
                        }

                        // Add OWNERSHIP Link
                        system.links.push({
                            from: parentName,
                            to: uniqueId,
                            type: 'OWNERSHIP',
                            tooltip: parentName + " owns " + item.name
                        });
                    }
                }
            });

            // 4. Procedures Pass (Logic)
            pack.items.forEach(function (item) {
                if (item.deleted) return;

                // OPL Procedures (Type 3)
                if (item.type === 3) {
                    system.nodes[item.name.toUpperCase()] = {
                        type: 'PROC',
                        packIndex: pIdx,
                        name: item.name,
                        label: item.name,
                        params: [],
                        locals: [],
                        globals: [], // Track used globals
                        degree: 0 // Track connections
                    };
                    packData.procedures.push(item.name);

                    // Build globalProcMap for accurately decompiling procedure calls
                    if (item.child) {
                        // Robust check: Procedure data is usually in item.child.child.data
                        // but we check both levels for resilience.
                        var target = (item.child.child && item.child.child.data) ? item.child.child : (item.child.data ? item.child : null);
                        if (target) {
                            try {
                                if (typeof OPLDecompiler !== 'undefined') {
                                    var tempDecompiler = new OPLDecompiler();
                                    var header = tempDecompiler.parseHeader(target.data, 0);
                                    if (header && header.numParams !== undefined) {
                                        globalProcMap[item.name.toUpperCase()] = { paramCount: header.numParams };
                                    }
                                }
                            } catch (e) { /* Ignore parse errors */ }
                        }
                    }
                }

                // Extract Globals from OPL Header
                if (item.type === 3) {
                    if (item.child && item.child.child && item.child.child.data) {
                        // Fix: Use getFullData() on the Type 0 (Long Record) parent to include the 02 80 header
                        // item.child is the Type 0 record (Header). item.child.child is the Body.
                        var data = (item.child.getFullData) ? item.child.getFullData() : item.child.child.data;

                        // Strict Parsing Helper (Inline/Scope)
                        function parseRec(d) {
                            var off = 0; while (off < d.length && d[off] === 0) off++;
                            var sync = -1; for (var i = off; i < d.length - 1; i++) { if (d[i] === 0x02 && d[i + 1] === 0x80) { sync = i; break; } }
                            if (sync === -1) return (d.length >= 2 && (2 + ((d[0] << 8) | d[1]) <= d.length)) ? { valid: true, off: 0, len: (d[0] << 8) | d[1], base: 0 } : { valid: false };
                            var lnOff = sync + 2; if (lnOff + 1 >= d.length) return { valid: false };
                            // Changed: Return sync as start offset (to include header)
                            return { valid: true, off: lnOff, len: (d[lnOff] << 8) | d[lnOff + 1], base: lnOff, sync: sync };
                        }

                        if (data.length >= 2) {
                            var struct = parseRec(data);
                            var obLen = struct.valid ? struct.len : 0;
                            var base = struct.valid ? struct.base : 2;

                            // Fix: Include '02 80' header in slice if valid container found
                            var startOff = (struct.valid && struct.sync !== undefined) ? struct.sync : base;
                            var totalLen = (struct.valid && struct.sync !== undefined) ? (obLen + 2) : obLen;

                            if (obLen > 0 && data.length >= startOff + totalLen) {
                                var objCode = data.slice(startOff, startOff + totalLen);
                                try {
                                    if (typeof OPLDecompiler !== 'undefined') {
                                        var decompiler = new OPLDecompiler();
                                        // objCode now includes '02 80' so parseHeader handles alignment correctly
                                        var header = decompiler.parseHeader(objCode, 0);
                                        // Run variable scan to populate inferred dimensions/lengths
                                        decompiler.scanVariables(objCode, header);

                                        if (header && header.globals) {
                                            var procNode = system.nodes[item.name.toUpperCase()];
                                            header.globals.forEach(function (g) {
                                                var gName = g.name.toUpperCase();

                                                // Construct Display Name (Dimensions)
                                                var displayName = g.name;
                                                if (g.arrayLen) {
                                                    if (g.name.endsWith('$') && g.maxLen) {
                                                        displayName += "(" + g.arrayLen + "," + g.maxLen + ")";
                                                    } else {
                                                        displayName += "(" + g.arrayLen + ")";
                                                    }
                                                } else {
                                                    if (g.name.endsWith('$') && g.maxLen) {
                                                        displayName += "(" + g.maxLen + ")";
                                                    }
                                                }

                                                // 1. Register Global Node
                                                if (!system.nodes[gName]) {

                                                    system.nodes[gName] = { type: 'GLOBAL', packIndex: pIdx, name: g.name, label: displayName, degree: 0, addr: g.addr };
                                                }
                                                // Always associate with pack (dedupe locally)
                                                if (packData.globals.indexOf(g.name) === -1) {
                                                    packData.globals.push(g.name);
                                                }

                                                // 2. Associate with Defining Procedure
                                                // Re-enabled: Users expect declared globals to be visible within the procedure scope.
                                                if (procNode && procNode.globals.indexOf(gName) === -1) {
                                                    procNode.globals.push(gName);
                                                }
                                            });
                                        }
                                    }
                                } catch (e) { /* Ignore parse errors */ }
                            }
                        }
                    }
                }
            });
            system.packs.push(packData);
        });
        // 2. Second Pass: Analyze Dependencies & Details
        packs.forEach(function (pack, pIdx) {
            // Build Global Address Map for this pack to resolve cross-procedure globals
            var globalAddrMap = {};
            if (system.packs[pIdx] && system.packs[pIdx].globals) {
                system.packs[pIdx].globals.forEach(function (gName) {
                    var gNode = system.nodes[gName.toUpperCase()];
                    if (gNode && gNode.addr !== undefined) {
                        var normAddr = gNode.addr;
                        if (normAddr > 32767) normAddr -= 65536; // Match Decompiler's signed logic
                        globalAddrMap[normAddr] = gName;
                    }
                });
            }

            pack.items.forEach(function (item) {
                if (item.deleted || item.type !== 3) return;

                var instructions = []; // Ensure defined
                if (item.child && item.child.child && item.child.child.data) {
                    // Fix: Use getFullData() to ensure OPLDecompiler receives the full Long Record (Header + Body)
                    var data = (item.child.getFullData) ? item.child.getFullData() : item.child.child.data;

                    // Helper: Detect Endianness / Structure (Strict)
                    // Updated 2025-12-29 to return start index for header inclusion.
                    function parseRecS(d) {
                        var off = 0; while (off < d.length && d[off] === 0) off++;
                        var sync = -1; for (var i = off; i < d.length - 1; i++) { if (d[i] === 0x02 && d[i + 1] === 0x80) { sync = i; break; } }
                        // Fallback logic for raw/legacy if no sync found
                        if (sync === -1) return (d.length >= 2 && (2 + ((d[0] << 8) | d[1]) <= d.length)) ?
                            { valid: true, len: (d[0] << 8) | d[1], base: 2, start: 0, type: 'raw' } : { valid: false };

                        var lnOff = sync + 2; if (lnOff + 1 >= d.length) return { valid: false };
                        return { valid: true, len: (d[lnOff] << 8) | d[lnOff + 1], base: lnOff + 2, start: sync, type: 'long' };
                    }

                    var st = parseRecS(data);

                    // Logic Setup
                    var obLen = st.valid ? st.len : ((data[0] << 8) | data[1]);
                    var baseStart = st.valid ? st.base : 2;

                    // For Decompiler: Use slice including 02 80 Header if available
                    // This ensures parseHeader in Main.js recognizes the record type.

                    // Only apply header logic if Long Record found
                    if (st.valid && st.type === 'long') {
                        var sliceEnd = st.start + 4 + st.len; // 02 80 Len Len [Body...]
                        if (sliceEnd <= data.length) {
                            var objCode = data.slice(st.start, sliceEnd);
                            try {
                                if (window.OPLDecompiler) {
                                    var decompiler = new window.OPLDecompiler();
                                    var analysis = decompiler.getControlFlow(objCode, item.name);
                                    item.instructions = analysis.instructions;
                                    item.flow = analysis.flow;
                                    item.varMap = analysis.varMap;
                                }
                            } catch (e) { }
                        }
                    } else if (obLen > 0 && data.length >= baseStart + obLen) {
                        // Fallback (Raw/Legacy)
                        // Try raw slice 
                        var objCode = data.slice(baseStart, baseStart + obLen);
                        try {
                            if (window.OPLDecompiler) {
                                var decompiler = new window.OPLDecompiler();
                                var analysis = decompiler.getControlFlow(objCode, item.name);
                                item.instructions = analysis.instructions;
                                item.flow = analysis.flow;
                                item.varMap = analysis.varMap;
                            }
                        } catch (e) { /* Ignore parse errors */ }
                    }

                    // 2. Get Full Source for Code Viewer & Regex Extraction
                    var fullCode = null;
                    var lncode = obLen;
                    var lnsrc = 0;
                    var srcOffset = baseStart + lncode;

                    if (data.length >= srcOffset + 2) {
                        lnsrc = (data[srcOffset] << 8) | data[srcOffset + 1];
                    }



                    if (lnsrc > 0 && data.length >= srcOffset + 2 + lnsrc) {
                        // Extract Source from Data
                        var srcBytes = data.slice(srcOffset + 2, srcOffset + 2 + lnsrc);
                        fullCode = "";
                        for (var i = 0; i < srcBytes.length; i++) {
                            var c = srcBytes[i];
                            fullCode += (c === 0 ? '\n' : String.fromCharCode(c));
                        }
                    } else if (item.text) {
                        fullCode = item.text; // Fallback to item.text if populated
                    } else {
                        // Fallback Decompilation
                        if (typeof objCode !== 'undefined' && window.OPLDecompiler) {
                            var d = (typeof decompiler !== 'undefined') ? decompiler : new window.OPLDecompiler();
                            fullCode = d.decompile(objCode, item.name, {});
                        }
                    }

                    var node = system.nodes[item.name.toUpperCase()];
                    if (node) {
                        node.code = fullCode;

                        var hasSource = (lnsrc > 0 && data.length >= lncode + 4 + lnsrc) || (item.text ? true : false);

                        if (!hasSource && item.varMap) {
                            // Fallback: Use Decompiler Analysis for Params & Locals
                            // 1. Params
                            var paramsList = [];
                            Object.keys(item.varMap).forEach(function (off) {
                                var v = item.varMap[off];
                                if (v.isParam) {
                                    var type = 'Float';
                                    var isArray = v.arrayLen > 0;
                                    if (v.type === 2) { type = isArray ? 'StringArray' : 'String'; }
                                    else if (v.type === 0) { type = isArray ? 'IntegerArray' : 'Integer'; }
                                    else if (v.type === 1) { type = isArray ? 'FloatArray' : 'Float'; }
                                    else if (v.type === 3) { type = 'IntegerArray'; }
                                    else if (v.type === 4) { type = 'FloatArray'; }
                                    else if (v.type === 5) { type = 'StringArray'; }
                                    paramsList.push({ name: v.name, type: type });
                                }
                            });
                            // Sort by P1, P2 etc.
                            paramsList.sort(function (a, b) {
                                var na = parseInt(a.name.replace(/^[P]/, ''));
                                var nb = parseInt(b.name.replace(/^[P]/, ''));
                                if (!isNaN(na) && !isNaN(nb)) return na - nb;
                                return a.name.localeCompare(b.name);
                            });
                            node.params = paramsList;

                            // 2. Locals
                            var localCount = 0;
                            Object.keys(item.varMap).forEach(function (off) {
                                var v = item.varMap[off];
                                if (v.isLocal && localCount < 50) {
                                    var display = v.name;
                                    if (v.arrayLen) {
                                        display += "(" + v.arrayLen;
                                        if (v.type === 2 && v.maxLen) display += "," + v.maxLen;
                                        display += ")";
                                    } else if (v.type === 2 && v.maxLen) {
                                        display += "(" + v.maxLen + ")";
                                    }
                                    node.locals.push(display);
                                    localCount++;
                                }
                            });

                        } else {
                            // Legacy: Extract from Text (Source or Decompiled Body)
                            // Extract Params
                            var procMatch = fullCode.match(/PROC\s+[A-Z0-9_$]+\s*:\s*\(([^)]*)\)/i);
                            if (procMatch && procMatch[1]) {
                                var rawParams = procMatch[1].split(',').map(s => s.trim()).filter(s => s);
                                node.params = rawParams.map(p => {
                                    var type = 'Float';
                                    if (p.endsWith('$')) type = 'String';
                                    else if (p.endsWith('%')) type = 'Integer';

                                    // Array Check
                                    if (p.includes('(')) {
                                        if (p.includes('$')) type = 'StringArray';
                                        else if (p.includes('%')) type = 'IntegerArray';
                                        else type = 'FloatArray';
                                        // Strip dimensions for name matching
                                        p = p.substring(0, p.indexOf('('));
                                    }
                                    return { name: p, type: type };
                                });
                            }

                            // Extract Locals
                            // Fix: Stop capturing at ':', 'REM', or newline to avoid capturing subsequent commands
                            var localRegex = /LOCAL\s+([^:\r\n]+)/ig;
                            var localMatch;
                            while ((localMatch = localRegex.exec(fullCode)) !== null) {
                                // Robustness: Strip REM comments and spaces
                                var content = localMatch[1].replace(/REM\s+.*/i, "");
                                var locals = content.split(',').map(s => s.trim()).filter(s => s);
                                // Keep dimensions for display
                                node.locals = node.locals.concat(locals);
                            }
                        }
                    }

                    if (item.instructions) instructions = item.instructions;

                    instructions.forEach(function (inst) {
                        // Find all calls in the instruction text (including within expressions)
                        // Find all calls in the instruction text (including within expressions)
                        // Modified: Capture identifier, handle optional colon manually.
                        var callRegex = /([A-Z0-9_$]+)/gi;
                        var match;
                        while ((match = callRegex.exec(inst.text)) !== null) {
                            var target = match[1].toUpperCase();

                            // Check following characters for Labels (::)
                            var idxAfter = match.index + match[0].length;
                            if (inst.text[idxAfter] === ':' && inst.text[idxAfter + 1] === ':') {
                                continue; // Ignore Labels (e.g. LABEL::)
                            }

                            if (system.nodes[target] && system.nodes[target].type === 'PROC') {
                                // Try to extract args for label
                                var args = '';
                                var afterColon = inst.text.substring(match.index + match[0].length).trim();
                                if (afterColon.startsWith('(')) {
                                    // Simple attempt to get args: content inside first set of parens
                                    // This is imperfect for nested calls but better than nothing
                                    var closeParen = afterColon.indexOf(')');
                                    if (closeParen !== -1) {
                                        args = afterColon.substring(1, closeParen);
                                    }
                                }

                                var type = 'Float';
                                if (target.endsWith('$')) type = 'String';
                                else if (target.endsWith('%')) type = 'Integer';

                                /* Fix: Add explicit tooltip for Calls to avoid confusion */
                                var tooltip = item.name.toUpperCase() + " -> " + target;
                                system.links.push({ from: item.name.toUpperCase(), to: target, type: 'CALL', label: args, dataType: type, tooltip: tooltip });
                                if (system.nodes[item.name.toUpperCase()]) system.nodes[item.name.toUpperCase()].degree++;
                                system.nodes[target].degree++;
                            }
                        }


                    });

                    // 3. Consolidated Global Usage Logic
                    // STAGE 1: Explicit Externals from Header (The Truth)
                    // We rely SOLELY on the OPL Header Externals for this feature as requested.

                    var headerUsage = null;
                    if (typeof decompiler !== 'undefined' && typeof objCode !== 'undefined') {
                        headerUsage = decompiler.parseHeader(objCode, 0);
                    }


                    if (headerUsage && headerUsage.externals) {
                        // DEBUG: Log externals found


                        headerUsage.externals.forEach(function (ext) {
                            var target = ext.name.toUpperCase();
                            var procName = item.name.toUpperCase();

                            // 1. Ensure Global Node Exists
                            if (!system.nodes[target]) {
                                system.nodes[target] = {
                                    type: 'GLOBAL',
                                    packIndex: pIdx,
                                    name: ext.name,
                                    label: ext.name, // Fix: Ensure label exists for display
                                    degree: 0,
                                    isImplicit: true
                                };
                                // Add to Pack's Global Pool if missing
                                if (system.packs[pIdx] && system.packs[pIdx].globals.indexOf(ext.name) === -1) {
                                    system.packs[pIdx].globals.push(ext.name);
                                }
                            }

                            // 2. Create GLOBAL_USAGE Link
                            var linkExists = system.links.some(l => l.from === target && l.to === procName && l.type === 'GLOBAL_USAGE');

                            if (!linkExists) {
                                var type = 'Float';
                                if (target.endsWith('$')) type = 'String';
                                else if (target.endsWith('%')) type = 'Integer';



                                system.links.push({
                                    from: target,
                                    to: procName,
                                    type: 'GLOBAL_USAGE',
                                    dataType: type,
                                    tooltip: "Global " + target + " used by " + procName,
                                    isImplicit: true
                                });

                                // Increment degrees
                                if (system.nodes[target]) system.nodes[target].degree++;
                                if (system.nodes[procName]) system.nodes[procName].degree++;
                            }
                        });
                    }


                    // STAGE 2: Explicit Globals from Header (Definitions)
                    if (headerUsage && headerUsage.globals) {
                        headerUsage.globals.forEach(function (g) {
                            var gName = g.name.toUpperCase();
                            var procName = item.name.toUpperCase();

                            // 1. Ensure Global Node Exists (Definition)
                            if (!system.nodes[gName]) {
                                var displayName = g.name;
                                // Reconstruct Display Name logic locally for robustness
                                if (g.arrayLen) {
                                    if (g.name.endsWith('$') && g.maxLen) displayName += "(" + g.arrayLen + "," + g.maxLen + ")";
                                    else displayName += "(" + g.arrayLen + ")";
                                } else if (g.name.endsWith('$') && g.maxLen) {
                                    displayName += "(" + g.maxLen + ")";
                                }

                                system.nodes[gName] = {
                                    type: 'GLOBAL',
                                    packIndex: pIdx,
                                    name: g.name,
                                    label: displayName,
                                    degree: 0,
                                    addr: g.addr
                                };
                                if (system.packs[pIdx] && system.packs[pIdx].globals.indexOf(g.name) === -1) {
                                    system.packs[pIdx].globals.push(g.name);
                                }
                            }

                            // 2. Register Ownership/Definition on Procedure Node
                            var procNode = system.nodes[procName];
                            if (procNode) {
                                if (!procNode.globals) procNode.globals = [];
                                if (procNode.globals.indexOf(g.name) === -1) {
                                    procNode.globals.push(g.name);
                                }
                            }
                            // Note: ACCESS link will be created by Post-Process based on procNode.globals list
                        });
                    }


                }
            });
        });

        // 3. Post-Process: Sync Links and List
        // Restore: Add detected global access to procedure's global list for display in the card
        system.links.forEach(function (link) {
            if (link.type === 'ACCESS') {
                var procNode = system.nodes[link.from];
                if (procNode) {
                    if (!procNode.globals) procNode.globals = [];
                    if (procNode.globals.indexOf(link.to) === -1) {
                        procNode.globals.push(link.to);
                    }
                }
            }
        });

        // Ensure reverse sync (List -> Link)
        Object.values(system.nodes).forEach(function (node) {
            if (node.type === 'PROC' && node.globals) {
                node.globals.forEach(function (gName) {
                    var hasLink = system.links.some(l => l.from === node.name.toUpperCase() && l.to === gName && l.type === 'ACCESS');
                    if (!hasLink) {
                        var type = 'Float';
                        if (gName.endsWith('$')) type = 'String';
                        else if (gName.endsWith('%')) type = 'Integer';
                        var tooltip = node.name.toUpperCase() + " - " + gName;
                        system.links.push({ from: node.name.toUpperCase(), to: gName, type: 'ACCESS', dataType: type, tooltip: tooltip });
                        if (system.nodes[gName]) system.nodes[gName].degree++;
                    }
                });
            }
        });

        return system;
    }

    // --- Layout Engine ---

    function calculateLayout(data, collapsedState, sectionState, containerState) {

        var packMargin = 50;
        var nodeWidth = 187;
        var nodeHeightExpanded = 160;
        var nodeHeightCollapsed = 32;
        var rankGap = 80;
        var nodeGap = 20;
        var cardPadding = 20;
        var innerCardPadding = 30;

        var globalPoolHeight = 80;
        var dataFileWidth = 187;
        var dataRecordHeight = 32;

        var currentY = packMargin;
        var layout = { nodes: {}, packs: [], innerCards: [], pools: [] };

        data.packs.forEach(function (pack) {
            // Collect nodes
            var packNodes = [];
            var procMap = {};
            pack.procedures.forEach(n => {
                packNodes.push({ name: n, type: 'PROC' });
                procMap[n] = { name: n, type: 'PROC', rank: 0, incoming: 0 };
            });

            // Calculate Ranks (Topological Sort / Longest Path)
            var localLinks = data.links.filter(l => procMap[l.from] && procMap[l.to]);

            // 1. Calculate In-Degrees
            localLinks.forEach(l => { procMap[l.to].incoming++; });

            // 2. Initialize Queue with Roots (In-Degree 0)
            var queue = Object.values(procMap).filter(n => n.incoming === 0);

            // Handle Case: No Roots (Cycle) - Force MAIN or First
            if (queue.length === 0 && packNodes.length > 0) {
                var main = packNodes.find(n => n.name.toUpperCase() === 'MAIN') || packNodes[0];
                var mainNode = procMap[main.name];
                mainNode.incoming = 0; // Break cycle
                queue.push(mainNode);
            }

            var visitedCount = 0;
            var totalNodes = Object.keys(procMap).length;

            while (queue.length > 0 || visitedCount < totalNodes) {
                if (queue.length === 0) {
                    // Cycle detected, pick next unprocessed node to break it
                    var unprocessed = Object.values(procMap).find(n => n.incoming > 0);
                    if (!unprocessed) break;
                    unprocessed.incoming = 0;
                    queue.push(unprocessed);
                }

                var curr = queue.shift();
                visitedCount++;

                var outgoing = localLinks.filter(l => l.from === curr.name);
                outgoing.forEach(l => {
                    var target = procMap[l.to];
                    if (target) {
                        // Longest Path: Rank is max of current or caller + 1
                        target.rank = Math.max(target.rank, curr.rank + 1);
                        target.incoming--;
                        if (target.incoming <= 0) {
                            target.incoming = 0; // Safety
                            queue.push(target);
                        }
                    }
                });
            }



            var ranks = [];
            Object.values(procMap).forEach(n => {
                if (!ranks[n.rank]) ranks[n.rank] = [];
                ranks[n.rank].push(n);
            });

            // Layout Calculation
            var startX = packMargin + cardPadding;
            var startY = currentY + cardPadding + 30;

            var innerX = startX;
            var innerY = startY;

            var maxRankHeight = 0;
            var rankHeights = [];

            // Helper to calculate node height
            function getNodeHeight(nodeName, isCollapsed) {
                if (isCollapsed) return nodeHeightCollapsed;

                var h = 32; // Header + Base Padding (Revised to 32 to match min height)
                var nodeData = data.nodes[nodeName.toUpperCase()];
                var sState = sectionState[nodeName.toUpperCase()] || { params: true, locals: false, globals: false }; // Default: Params Open, Locals/Globals Closed

                if (nodeData) {
                    // Params Section
                    if (nodeData.params && nodeData.params.length > 0) {
                        h += 20; // Title
                        if (sState.params) {
                            h += nodeData.params.length * 14; // Items
                            h += 25; // Scrollbar & Padding Buffer
                        } else {
                            h += 5; // Padding when collapsed
                        }
                    }

                    // Locals Section
                    if (nodeData.locals && nodeData.locals.length > 0) {
                        h += 20; // Title
                        if (sState.locals) {
                            h += nodeData.locals.length * 14;
                            h += 25; // Scrollbar & Padding Buffer
                        } else {
                            h += 5; // Padding when collapsed
                        }
                    }

                    // Globals Section
                    if (nodeData.globals && nodeData.globals.length > 0) {
                        h += 20; // Title
                        if (sState.globals) {
                            h += nodeData.globals.length * 14;
                            h += 25; // Scrollbar & Padding Buffer
                        } else {
                            h += 5; // Padding when collapsed
                        }
                    }
                }

                if (!isCollapsed && h > 32) {
                    h += 7; // Top+Bottom Padding (5+2)
                }
                return Math.max(h, 32); // Min height reduced from 40 to 32 (consistent with collapsed)
            }

            // First pass: Calculate height of each rank based on collapsed state
            ranks.forEach((rankNodes, rIdx) => {
                var h = 0;
                rankNodes.forEach(node => {
                    var isCollapsed = collapsedState[node.name.toUpperCase()];
                    h += getNodeHeight(node.name, isCollapsed) + nodeGap;
                });
                h -= nodeGap;
                rankHeights[rIdx] = h;
                if (h > maxRankHeight) maxRankHeight = h;
            });

            var innerW = innerCardPadding * 2 + (ranks.length * (nodeWidth + rankGap)) - rankGap;
            if (innerW < 250) innerW = 250;
            var innerH = innerCardPadding * 2 + maxRankHeight + 30;
            if (innerH < 150) innerH = 150;

            // Logic Container Collapse
            var logicCollapsed = containerState && containerState[pack.name] && containerState[pack.name].logic;
            if (logicCollapsed) {
                innerH = 30; // Header only
            }

            layout.innerCards.push({ x: innerX, y: innerY, w: innerW, h: innerH, label: "Hierarchy & Flow", packName: pack.name, type: 'logic', collapsed: logicCollapsed });

            if (!logicCollapsed) {
                ranks.forEach((rankNodes, rIdx) => {
                    var rankX = innerX + innerCardPadding + rIdx * (nodeWidth + rankGap);
                    var rankH = rankHeights[rIdx];
                    var offsetY = (maxRankHeight - rankH) / 2;
                    var currentRankY = innerY + innerCardPadding + 30 + offsetY;

                    rankNodes.forEach((node, nIdx) => {
                        var isCollapsed = collapsedState[node.name.toUpperCase()];
                        var h = getNodeHeight(node.name, isCollapsed);

                        var nodeData = data.nodes[node.name.toUpperCase()];
                        layout.nodes[node.name.toUpperCase()] = {
                            x: rankX,
                            y: currentRankY,
                            w: nodeWidth,
                            h: h,
                            type: 'PROC',
                            id: node.name.toUpperCase(),
                            label: node.name,
                            packName: pack.name, // Added for collapse filtering
                            code: nodeData ? nodeData.code : null,
                            params: nodeData ? nodeData.params : [],
                            locals: nodeData ? nodeData.locals : [],
                            globals: nodeData ? nodeData.globals : [],

                            collapsed: isCollapsed,
                            rank: node.rank,
                            packName: pack.name
                        };

                        currentRankY += h + nodeGap;
                    });
                });
            }

            var poolY = innerY + innerH + 20;
            var poolW = innerW;

            // Calculate grid for Globals (Full Width Nodes)
            var globalsCols = Math.floor((poolW - 20) / (nodeWidth + 80)); // Increased horizontal spacing
            if (globalsCols < 1) globalsCols = 1;
            var globalsRows = Math.ceil(pack.globals.length / globalsCols);

            var globalNodeHeight = 32; // Reduced from 40 to match Header height (no body content)
            var poolH = globalsRows * (globalNodeHeight + 20) + 70; // +70 for header/padding (increased from 40)

            // Global Pool Collapse
            var globalsCollapsed = containerState && containerState[pack.name] && containerState[pack.name].globals;
            if (globalsCollapsed) {
                poolH = 30; // Header only
            }

            layout.pools.push({ x: innerX, y: poolY, w: poolW, h: poolH, label: "Global Space", packName: pack.name, type: 'globals', collapsed: globalsCollapsed });

            if (!globalsCollapsed) {
                pack.globals.forEach((gName, gIdx) => {
                    var gCol = gIdx % globalsCols;
                    var gRow = Math.floor(gIdx / globalsCols);
                    var nodeData = data.nodes[gName.toUpperCase()];
                    var isCollapsed = collapsedState[gName.toUpperCase()];
                    var h = isCollapsed ? nodeHeightCollapsed : globalNodeHeight;

                    layout.nodes[gName.toUpperCase()] = {
                        x: innerX + 30 + gCol * (nodeWidth + 80), // Aligned with Procedures (innerCardPadding = 30)
                        y: poolY + 60 + gRow * (globalNodeHeight + 20), // Increased Padding (was +35)
                        w: nodeWidth, // Full Width
                        h: h,
                        type: 'GLOBAL',
                        id: gName.toUpperCase(),
                        label: (nodeData && nodeData.label && nodeData.label !== 'undefined') ? nodeData.label : gName, // Robust fallback
                        code: null,
                        packName: pack.name, // Added for collapse filtering
                        collapsed: isCollapsed,
                        rank: gCol // Assign Rank based on Column for Routing Collision Detection
                    };
                });
            }

            var packW = innerW + cardPadding * 2;
            var packH = (poolY + poolH) - currentY + cardPadding;

            // Data Space Layout
            var dataY = poolY + poolH + 20;
            var dataH = 0;
            var dataFiles = pack.dataFiles || [];

            if (dataFiles.length > 0) {
                // Calculate Height
                var maxDataH = 0;
                var dataCols = Math.floor((innerW - 20) / (dataFileWidth + 80));
                if (dataCols < 1) dataCols = 1;

                dataFiles.forEach((dfName, i) => {
                    var fileNode = data.nodes[dfName.toUpperCase()];
                    var records = fileNode.records || [];

                    var isCollapsed = collapsedState[dfName.toUpperCase()];
                    if (isCollapsed === undefined) {
                        isCollapsed = true;
                        collapsedState[dfName.toUpperCase()] = true;
                    }

                    var h = nodeHeightCollapsed; // Header
                    if (!isCollapsed) {
                        h += 10; // Padding
                        if (records.length > 0) {
                            h += records.length * (dataRecordHeight + 10);
                        } else {
                            h += 30; // "No Records" placeholder space
                        }
                    }
                    // Set height on node for calculation
                    fileNode._calcHeight = h;
                });

                var rows = Math.ceil(dataFiles.length / dataCols);

                // Calculate total height based on max height in each row? 
                // Or simplified: Just stack them if needed, or grid.
                // Let's find max height per row.
                var rowHeights = [];
                for (var r = 0; r < rows; r++) {
                    var maxH = 0;
                    for (var c = 0; c < dataCols; c++) {
                        var idx = r * dataCols + c;
                        if (idx < dataFiles.length) {
                            var dfName = dataFiles[idx];
                            var h = data.nodes[dfName.toUpperCase()]._calcHeight;
                            if (h > maxH) maxH = h;
                        }
                    }
                    rowHeights[r] = maxH;
                }

                dataH = rowHeights.reduce((a, b) => a + b, 0) + (rows * 20) + 50; // +Header
            }

            // Data Space Collapse
            var dataCollapsed = containerState && containerState[pack.name] && containerState[pack.name].data;
            if (dataCollapsed) {
                dataH = 30;
            }

            if (dataFiles.length > 0) {
                layout.pools.push({
                    x: innerX,
                    y: dataY,
                    w: innerW,
                    h: dataH,
                    label: "Data Space",
                    packName: pack.name,
                    type: 'data',
                    collapsed: dataCollapsed
                });

                if (!dataCollapsed) {
                    var currentDataRowY = dataY + 50;
                    var dataCols = Math.floor((innerW - 20) / (dataFileWidth + 80));
                    if (dataCols < 1) dataCols = 1;

                    var rowH = 0;
                    var rowNodes = [];

                    dataFiles.forEach((dfName, i) => {
                        var col = i % dataCols;
                        if (col === 0 && i > 0) {
                            // New Row
                            currentDataRowY += rowH + 20;
                            rowH = 0;
                        }

                        var fileNode = data.nodes[dfName.toUpperCase()];
                        var h = fileNode._calcHeight;
                        if (h > rowH) rowH = h;

                        var x = innerX + 30 + col * (dataFileWidth + 80);
                        var y = currentDataRowY;

                        // Layout Data File
                        layout.nodes[dfName.toUpperCase()] = {
                            x: x, y: y, w: dataFileWidth, h: h,
                            type: 'DATA_FILE',
                            id: dfName.toUpperCase(),
                            label: fileNode.label,
                            packName: pack.name, // Added for collapse filtering
                            collapsed: collapsedState[dfName.toUpperCase()],
                            rank: col // Assign Rank based on Column
                        };

                        // Layout Records (Inside the File Card visually)
                        if (!collapsedState[dfName.toUpperCase()]) {
                            var records = fileNode.records;
                            records.forEach((recName, rIdx) => {
                                layout.nodes[recName] = {
                                    x: x + 20, // Indented
                                    y: y + 40 + rIdx * (dataRecordHeight + 10),
                                    w: dataFileWidth - 40,
                                    h: dataRecordHeight,
                                    type: 'DATA_RECORD',
                                    id: recName,
                                    label: data.nodes[recName].label,
                                    parent: dfName.toUpperCase(),
                                    packName: pack.name, // Added for collapse filtering
                                    rank: col // Inherit Rank from File
                                };
                            });
                        }
                    });
                }
            } else {
                dataH = 0; // No data space if no files
            }

            var packW = innerW + cardPadding * 2;
            var packH = (dataY + (dataFiles.length > 0 ? dataH : 0)) - currentY + cardPadding;

            // Adjust if logic/globals were essentially empty/collapsed but data is there
            if (packH < 100) packH = 100;

            // Pack Collapse
            var packCollapsed = containerState && containerState[pack.name] && containerState[pack.name].pack;
            if (packCollapsed) {
                packH = 30 + cardPadding; // Header + padding
                // If pack is collapsed, we might want to hide inner cards?
                // But layout.innerCards are already pushed.
                // Simpler: Just render the pack rect small and don't render children in draw().
                // But calculateLayout returns positions.
                // Let's just set height. The draw loop will need to know to skip children if pack is collapsed.
                // Or we can remove them from layout.innerCards/pools here?
                // Removing them is cleaner for drawing.
                if (packCollapsed) {
                    // Remove the last pushed innerCard and pool
                    layout.innerCards.pop();
                    layout.pools.pop();
                    // Clear nodes for this pack?
                    // The nodes are in layout.nodes map. We need to remove them.
                    // Re-iterating to remove is inefficient.
                    // Better: Don't push them if pack is collapsed.
                    // But we already pushed them above.
                    // Refactor: Check packCollapsed at start of loop?
                }
            }

            // REFACTOR: Pack Collapse Check at Start
            // Since we can't easily refactor the whole loop in one go with replace, let's handle it by
            // filtering layout.nodes at the end or just hiding them in draw.
            // For now, let's just PUSH THE PACK so validation works.
            layout.packs.push({
                x: packMargin,
                y: currentY,
                w: packW,
                h: packH,
                label: pack.name,
                packName: pack.name, // CRITICAL: Required for toggleContainer
                type: 'pack',
                collapsed: packCollapsed
            });

            currentY += packH + packMargin;
        });


        return layout;
    }


    // --- Window Management ---

    var childWindow = null;
    var lastData = null; // Store data for delayed render

    function handleChildReady(winUrlOrMsg) {
        // Support both Direct Window Reference (Legacy/Firefox) and Message Event (Chrome)
        // If passed a Window object:
        if (winUrlOrMsg && winUrlOrMsg.postMessage) {
            childWindow = winUrlOrMsg;
        }
        // If passed an Event object (from message listener):
        else if (winUrlOrMsg && winUrlOrMsg.source) {
            childWindow = winUrlOrMsg.source;
        }

        if (childWindow) {
            // setupChildWindow(childWindow); // REMOVED: Parent cannot access Child DOM in Chrome

            // Send Data Back
            if (lastData) {
                // Delay slightly to ensure DOM is digested
                setTimeout(function () {
                    // Try PostMessage First (Secure/Chrome)
                    childWindow.postMessage({ type: 'RENDER_GRAPH', data: lastData }, '*');

                    // Fallback to Direct Access (if same origin and allowed)
                    try {
                        if (childWindow.renderSystemMap) {
                            childWindow.renderSystemMap(lastData, childWindow);
                        }
                    } catch (e) { /* Expected in Chrome local file */ }
                }, 100);
            }
        }
    }

    // --- Message Listner Upgrade ---
    function setupMessageListeners() {
        window.addEventListener('message', function (event) {
            if (!event.data) return;

            // Parent Logic: Receive Ready signal from Child
            if (event.data.type === 'VISUALIZER_READY') {
                handleChildReady(event);
            }

            // Child Logic: Receive Graph Data from Parent
            if (event.data.type === 'RENDER_GRAPH') {
                var data = event.data.data;
                // We are the child. We need to render.
                // renderSystemMap expects (data, win). 'win' is us (window).
                if (window.document.getElementById('graph-container')) {
                    renderSystemMap(data, window);
                } else {
                    // Stash it?
                    // CodeVisualizer logic usually assumes we ARE the visualizer window if we have graph-container.
                }
            }
        });
    }
    setupMessageListeners();

    function openWindow() {
        var width = 1400;
        var height = 900;
        var left = (screen.width - width) / 2;
        var top = (screen.height - height) / 2;

        if (childWindow && !childWindow.closed) {
            childWindow.focus();
            return childWindow; // Might be ready or not
        }

        // Use index.html with child mode
        var win = window.open("index.html?mode=child&feature=visualizer", "OPKSystemMap", `width=${width},height=${height},top=${top},left=${left}`);

        if (!win) {
            alert("Please allow popups to view the System Map.");
            return null;
        }

        childWindow = win;
        return win;
    }

    function initChildEnvironment() {
        var win = window;
        if (!win || !win.document) return;

        // 1. Calculate Theme Vars
        var cssVars = "";
        var bodyClass = "";
        var currentTheme = '';
        var baseHref = window.location.href;

        if (typeof ThemeManager !== 'undefined') {
            currentTheme = ThemeManager.currentTheme;
            var defs = ThemeManager.getThemeDefinition(currentTheme);
            for (var key in defs) {
                cssVars += `${key}: ${defs[key]};\n`;
            }
            bodyClass = document.body.className;
        }

        // 2. Inject Styles and Content
        var doc = win.document;

        // Ensure <base> tag is present (for relative links if needed, though we use index.html now)
        // Actually index.html will have correct base if loaded from same dir.
        // But we want to enforce styles.

        // Apply Theme Vars to HTML/Body
        var html = doc.documentElement;
        if (html) {
            html.style.cssText = cssVars;
            html.setAttribute('data-theme', currentTheme);
        }
        if (doc.body) doc.body.className = bodyClass;

        // Custom Visualizer Styles
        var style = doc.createElement('style');
        style.textContent = `
                    :root {
                        --container-bg: var(--bg-color);
                        --container-border: var(--border-color);
                        --container-header-bg: var(--sidebar-header-bg);
                        
                        --node-bg: var(--bg-color);
                        --node-border: var(--border-color);
                        --node-header-bg: var(--list-hover-bg);
                        --node-shadow: 0 2px 5px rgba(0,0,0,0.1);
                        
                        --link-color: var(--text-color);
                    }
                    /* Data File Styling */
                    .node.data_file .node-header { 
                        background-color: var(--node-header-bg); 
                        color: var(--text-color); 
                    }
                    .node.data_file .node-type {
                        color: var(--text-color); 
                        opacity: 0.6;
                    }
                    .node.data_record .node-card { 
                        border-left: 4px solid #4CAF50; 
                    }
                    .node.data_record .node-header {
                        background-color: var(--node-header-bg);
                    }
                    body {
                        background-color: var(--bg-color);
                        color: var(--text-color);
                        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                        margin: 0;
                        padding: 0;
                        overflow: hidden; /* Prevent body scroll */
                        display: flex;
                        flex-direction: column; 
                        height: 100vh;
                    }
                    #main-container {
                        display: flex;
                        width: 100%;
                        flex: 1; 
                        overflow: hidden;
                    }
                    #graph-pane {
                        flex: 1;
                        position: relative;
                        overflow: hidden; 
                        background: var(--bg-color);
                        min-width: 200px;
                        display: flex;
                        flex-direction: column;
                    }
                    #graph-scroll {
                        flex: 1;
                        overflow: auto; 
                        position: relative;
                        width: 100%;
                        height: 100%;
                    }
                    #resizer {
                        width: 5px;
                        background: var(--border-color);
                        cursor: col-resize;
                        z-index: 100;
                        transition: background 0.2s;
                    }
                    #resizer:hover, #resizer.active {
                        background: var(--syntax-keyword); 
                    }
                    #code-pane {
                        width: 450px;
                        background: var(--bg-color);
                        display: flex;
                        flex-direction: column;
                        box-shadow: -2px 0 5px rgba(0,0,0,0.05);
                        z-index: 10;
                        min-width: 200px; 
                        display: none; 
                    }

                    #controls {
                        width: 100%;
                        height: 40px;
                        border-bottom: 1px solid var(--border-color);
                        background: var(--container-header-bg); 
                        display: flex;
                        align-items: center;
                        padding: 0 10px;
                        box-sizing: border-box;
                        gap: 10px;
                        z-index: 100;
                    }
                    #controls button {
                        padding: 5px;
                        border: 1px solid var(--border-color);
                        background: var(--bg-color);
                        color: var(--text-color);
                        cursor: pointer;
                        border-radius: 4px;
                        font-family: inherit;
                        font-weight: bold;
                        min-width: 28px; 
                        height: 28px; 
                        text-align: center;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    }
                    #btn-fit {
                        min-width: auto; 
                        padding: 5px 10px; 
                    }
                    #controls button:hover {
                        background: var(--list-hover-bg);
                    }
                    
                    /* Inner Containers */
                    .inner-container {
                        border: 1px solid var(--border-color);
                        border-radius: 6px; 
                        background: var(--container-header-bg); 
                        margin-bottom: 5px;
                        overflow: hidden;
                    }
                    .section-title {
                        font-size: 10px;
                        color: var(--text-color);
                        opacity: 0.8;
                        text-transform: uppercase;
                        padding: 2px 5px;
                        background: rgba(0,0,0,0.05);
                        cursor: pointer;
                        font-weight: bold;
                        border-bottom: 1px solid transparent;
                    }
                    .section-title:hover {
                        background: rgba(0,0,0,0.1);
                    }
                    .section-list {
                        padding: 5px;
                        font-family: 'Consolas', monospace;
                        font-size: 11px;
                        color: var(--text-color);
                        background: var(--bg-color);
                        display: flex;
                        flex-direction: column; 
                        overflow-x: auto; 
                    }
                    .item { 
                        margin-bottom: 2px; 
                        display: block;
                        white-space: nowrap; 
                    }
                    
                    /* Node Styles */
                    #code-content {
                        white-space: pre; 
                        font-family: 'Consolas', 'Courier New', monospace;
                        overflow: auto;
                        font-size: 11px;
                        flex: 1;
                        padding: 10px;
                    }

                    .node-card {
                        width: 100%;
                        height: 100%;
                        background: var(--node-bg);
                        border: 1px solid var(--node-border);
                        border-radius: 8px;
                        box-shadow: var(--node-shadow);
                        display: flex;
                        flex-direction: column;
                        overflow: hidden;
                        font-size: 12px;
                        box-sizing: border-box;
                    }

                    .node-header {
                        background: var(--node-header-bg);
                        color: var(--text-color);
                        padding: 4px 8px;
                        font-weight: bold;
                        border-bottom: 1px solid var(--node-border);
                        display: flex;
                        align-items: center;
                        position: relative;
                        height: 32px; 
                        box-sizing: border-box; 
                        text-shadow: 0px 1px 2px rgba(0, 0, 0, 0.8); 
                    }
                    .node-title {
                        flex: 1;
                        text-align: left;
                        white-space: nowrap;
                        overflow: hidden;
                        text-overflow: ellipsis;
                    }
                    .node-type {
                        font-size: 9px;
                        color: var(--text-color);
                        opacity: 0.6;
                        margin-left: auto; 
                        padding-left: 5px;
                        padding-right: 5px;
                        text-transform: uppercase;
                    }
                    .node-icon {
                        cursor: pointer;
                        font-size: 10px;
                        width: 14px;
                        height: 14px;
                        line-height: 14px;
                        text-align: center;
                        border: 1px solid var(--border-color);
                        border-radius: 2px;
                        background: var(--bg-color);
                        margin-left: 5px; 
                    }
                    .node-body {
                        flex: 1;
                        padding: 5px 5px 2px 5px;
                        overflow-y: auto;
                        display: block;
                    }
                    .node-card.collapsed .node-body {
                        display: none;
                    }
                    .node-card.collapsed .node-header,
                    .node-card.global .node-header,
                    .node-card.empty .node-header {
                        flex: 1; 
                        height: 100%; 
                        border-bottom: none; 
                    }
                    .node-card:hover { border-color: var(--text-color); box-shadow: 0 4px 8px rgba(0,0,0,0.15); }
                    .node-card.active { border-color: var(--syntax-keyword); border-width: 2px; }

                    /* Type Color Bands (Top Left) */
                    .node-header.type-int { border-left: 4px solid #00AA00; }
                    .node-header.type-str { border-left: 4px solid #AA00AA; }
                    .node-header.type-float { border-left: 4px solid #FF8800; }

                    /* Link Styles */
                    .link {
                        stroke: var(--link-color);
                        stroke-width: 1.5;
                        fill: none;
                        stroke-opacity: 0.7;
                    }
                    .link.access { stroke-dasharray: 3,3; stroke-opacity: 0.5; }
                    .link.global_usage { stroke-dasharray: 3,3; stroke-opacity: 0.5; }
                    
                    /* Highlight Effect */
                    .link.highlighted {
                        stroke-width: 3 !important;
                        stroke-opacity: 1 !important;
                        animation: pulse-path 0.33s ease-in-out infinite;
                    }
                    @keyframes pulse-path {
                        0% { stroke-opacity: 1; stroke-width: 3; filter: drop-shadow(0 0 2px currentColor); }
                        50% { stroke-opacity: 1; stroke-width: 5; filter: drop-shadow(0 0 6px currentColor); }
                        100% { stroke-opacity: 1; stroke-width: 3; filter: drop-shadow(0 0 2px currentColor); }
                    }
                    
                    .link-label {
                        fill: var(--text-color);
                        font-size: 10px;
                        font-family: 'Consolas', monospace;
                        font-weight: bold;
                        filter: url(#text-bg);
                    }
                    
                    /* Container Styles */
                    .container-rect {
                        fill: var(--container-bg);
                        stroke: var(--container-border);
                        stroke-width: 1;
                        rx: 12; ry: 12;
                    }
                    .card-main .container-rect {
                        stroke: var(--text-color); 
                        stroke-width: 2;
                        fill: var(--bg-color); 
                        opacity: 0.8; 
                    }
                    .card-inner .container-rect, .global-pool .container-rect, .data-pool .container-rect {
                        fill: var(--container-header-bg); 
                        opacity: 0.5; 
                    }
                    .container-title {
                        fill: var(--text-color);
                        font-size: 14px;
                        font-weight: bold;
                        text-transform: uppercase;
                        text-anchor: start; 
                        dominant-baseline: middle;
                    }

                    /* Legend Window */
                    #legend-window {
                        position: absolute; 
                        top: 10px;
                        right: 20px; 
                        width: 200px;
                        background: var(--bg-color);
                        border: 1px solid var(--border-color);
                        box-shadow: 0 4px 10px rgba(0,0,0,0.2);
                        z-index: 1000;
                        padding: 10px;
                        border-radius: 4px;
                        display: block; 
                        font-family: 'Segoe UI', sans-serif;
                        font-size: 11px;
                    }
                    #legend-header {
                        font-weight: bold;
                        border-bottom: 1px solid var(--border-color);
                        padding-bottom: 5px;
                        margin-bottom: 5px;
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                    }
                    .legend-close { cursor: pointer; opacity: 0.6; font-size: 14px; }
                    .legend-close:hover { opacity: 1; }
                    .legend-item { display: flex; align-items: center; margin-bottom: 5px; }
                    .legend-line { width: 30px; height: 2px; margin-right: 8px; border-radius: 1px; }
                    .legend-label { flex: 1; color: var(--text-color); }
                    
                    /* Legend Colors */
                    .bg-int { background-color: #00AA00; }
                    .bg-str { background-color: #AA00AA; }
                    .bg-float { background-color: #FF8800; }
                    .bg-long { background-color: #0000AA; }
                    .bg-void { background-color: #888888; }
                    .bg-solid { border-bottom: 2px solid; } 
                    .bg-dashed { border-bottom: 2px dashed; background: none !important; } 

                    /* Legend Tabs */
                    .legend-tabs { display: flex; border-bottom: 1px solid var(--border-color); margin-bottom: 10px; }
                    .legend-tab { 
                        flex: 1; 
                        text-align: center; 
                        padding: 5px; 
                        cursor: pointer; 
                        font-size: 10px; 
                        opacity: 0.7;
                        border-bottom: 2px solid transparent;
                    }
                    .legend-tab:hover { opacity: 1; background: var(--list-hover-bg); }
                    .legend-tab.active { opacity: 1; border-bottom-color: var(--syntax-keyword); font-weight: bold; }
                    .legend-panel { display: none; }
                    .legend-panel.active { display: block; }
        `;
        doc.head.appendChild(style);

        // 3. Inject HTML Body Content (Using innerHTML)
        doc.body.innerHTML = `
                <div id="controls">
                            <button id="btn-toggle-calls" title="Toggle Procedure Call Links (Proc -> Proc)" style="margin-right: 5px;">
                                <svg style="width:14px;height:14px" viewBox="0 0 24 24">
                                    <path fill="currentColor" d="M14,4L20,10L14,16V13H11C8.79,13 7,14.79 7,17V21H5V17A4,4 0 0,1 9,13H14V10L14,4Z" />
                                </svg>
                            </button>
                            <button id="btn-toggle-access" title="Toggle Global Access Links (Proc -> Global)" style="margin-right: 5px;">
                                <svg style="width:14px;height:14px" viewBox="0 0 24 24">
                                    <path fill="currentColor" d="M12,3C7.58,3 4,4.79 4,7C4,9.21 7.58,11 12,11C16.42,11 20,9.21 20,7C20,4.79 16.42,3 12,3M4,9V12C4,14.21 7.58,16 12,16C12.5,16 13,15.97 13.5,15.9V13.88C12.96,13.96 12.5,14 12,14C7.58,14 4,12.21 4,10C4,9.73 4.07,9.47 4.21,9.21L4,9M4,14V17C4,19.21 7.58,21 12,21C12.5,21 13,20.97 13.5,20.9V18.88C12.96,18.96 12.5,19 12,19C7.58,19 4,17.21 4,15C4,14.73 4.07,14.47 4.21,14.21L4,14M18,14L22,18L18,22V19H15V17H18V14Z" />
                                </svg>
                            </button>
                            <button id="btn-toggle-links" title="Toggle Global Usage Links (Global -> Proc)" style="margin-right: 5px;">
                                <svg style="width:14px;height:14px" viewBox="0 0 24 24">
                                    <path fill="currentColor" d="M17.9,17.39C17.64,16.59 16.89,16 16,16H15V13A1,1 0 0,0 14,12H8V10H10A1,1 0 0,0 11,9V7H13A2,2 0 0,0 15,5V4.59C17.93,5.77 20,8.64 20,12C20,14.08 19.2,15.97 17.9,17.39M11,19.93C7.05,19.44 4,16.08 4,12C4,11.38 4.08,10.78 4.21,10.21L9,15V16A2,2 0 0,0 11,18M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z" />
                                </svg>
                            </button>
                            <button id="btn-expand-all" title="Expand All Procedures" style="margin-left: 10px; margin-right: 5px;">
                                <svg style="width:14px;height:14px" viewBox="0 0 24 24">
                                    <path fill="currentColor" d="M19,13H13V19H11V13H5V11H11V5H13V11H19V13Z" />
                                </svg>
                            </button>
                            <button id="btn-collapse-all" title="Collapse All Procedures" style="margin-right: 5px;">
                                <svg style="width:14px;height:14px" viewBox="0 0 24 24">
                                    <path fill="currentColor" d="M19,13H5V11H19V13Z" />
                                </svg>
                            </button>
                    <!-- 5 Buttons moved left -->
                    <div style="width:1px; height: 20px; background:var(--border-color); margin:0 5px;"></div>
                    <button id="btn-fit">Fit</button>
                    <button id="btn-zoom-in">+</button>
                    <button id="btn-zoom-out">-</button>
                    
                    <div style="width:1px; height: 20px; background:var(--border-color); margin:0 5px;"></div>
                    
                    <button id="btn-toggle-code" title="Toggle Procedure View">Code</button>
                    <button id="btn-legend" title="Link Key / Legend">Key</button>
                </div>
                
                <div id="main-container">
                    <div id="graph-pane">
                        <div id="legend-window">
                    <div id="legend-header">
                        <span>Link Key</span>
                        <span id="btn-close-legend" class="legend-close">&times;</span>
                    </div>
                    
                    <div class="legend-tabs">
                        <div class="legend-tab active" data-tab="tab-calls" title="Procedure Parameters (Proc -> Proc)">Calls</div>
                        <div class="legend-tab" data-tab="tab-usage" title="Global Definitions (Global -> Proc)">Defs</div>
                        <div class="legend-tab" data-tab="tab-access" title="Global Use (Proc -> Global)">Access</div>
                    </div>

                    <div id="tab-calls" class="legend-panel active">
                        <div style="font-size:10px; margin-bottom:5px; opacity:0.7">Procedure Parameters</div>
                        <div class="legend-item"><input type="checkbox" id="chk-calls-int" checked style="margin-right:5px"><div class="legend-line bg-int"></div><span class="legend-label">Integer</span></div>
                        <div class="legend-item"><input type="checkbox" id="chk-calls-str" checked style="margin-right:5px"><div class="legend-line bg-str"></div><span class="legend-label">String</span></div>
                        <div class="legend-item"><input type="checkbox" id="chk-calls-float" checked style="margin-right:5px"><div class="legend-line bg-float"></div><span class="legend-label">Float</span></div>
                    </div>

                    <div id="tab-usage" class="legend-panel">
                        <div style="font-size:10px; margin-bottom:5px; opacity:0.7">Global Use</div>
                        <div class="legend-item"><input type="checkbox" id="chk-access-int" checked style="margin-right:5px"><div class="legend-line bg-int"></div><span class="legend-label">Integer</span></div>
                        <div class="legend-item"><input type="checkbox" id="chk-access-str" checked style="margin-right:5px"><div class="legend-line bg-str"></div><span class="legend-label">String</span></div>
                        <div class="legend-item"><input type="checkbox" id="chk-access-float" checked style="margin-right:5px"><div class="legend-line bg-float"></div><span class="legend-label">Float</span></div>
                    </div>

                    <div id="tab-access" class="legend-panel">
                        <div style="font-size:10px; margin-bottom:5px; opacity:0.7">Global Definitions</div>
                        <div class="legend-item"><input type="checkbox" id="chk-usage-int" checked style="margin-right:5px"><div class="legend-line bg-int"></div><span class="legend-label">Integer</span></div>
                        <div class="legend-item"><input type="checkbox" id="chk-usage-str" checked style="margin-right:5px"><div class="legend-line bg-str"></div><span class="legend-label">String</span></div>
                        <div class="legend-item"><input type="checkbox" id="chk-usage-float" checked style="margin-right:5px"><div class="legend-line bg-float"></div><span class="legend-label">Float</span></div>
                    </div>

                    <!-- Static Line Type Key -->
                    <div style="height:1px; background:var(--border-color); margin:5px 0;"></div>
                    <div class="legend-item"><div class="legend-line bg-void" style="background:currentColor"></div><span class="legend-label">Procedure Call (Solid)</span></div>
                    <div class="legend-item"><div class="legend-line" style="border-top:2px dashed currentColor; background:none; height:0;"></div><span class="legend-label">Global Access (Dashed)</span></div>

                </div>
                        <div id="graph-scroll">
                            <div id="graph-container"></div>
                        </div>
                    </div>
                    <div id="resizer"></div> <!-- Resizer Handle -->
                    <div id="code-pane">
                        <div id="code-header">Select a procedure</div>
                        <div id="code-content"></div>
                    </div>
                </div>
        `;

        // 4. Attach Setup Logic (Replaces the <script>)
        var activeEditor = null;
        var CodeEditor = window.CodeEditor; // Assuming loaded via index.html or parent

        // Define win.showCode
        win.showCode = function (code, title) {
            var header = doc.getElementById('code-header');
            var content = doc.getElementById('code-content');
            if (header) header.textContent = title;
            if (content) {
                if (activeEditor) {
                    activeEditor.setValue(code || "");
                } else if (CodeEditor) {
                    content.innerHTML = '';
                    activeEditor = new CodeEditor(content, {
                        readOnly: true,
                        value: code || "",
                        language: 'opl'
                    });
                } else {
                    content.innerHTML = '';
                    var pre = doc.createElement('pre');
                    pre.style.margin = "0"; pre.style.padding = "10px";
                    pre.style.fontFamily = "Consolas, 'Courier New', monospace";
                    pre.style.fontSize = "12px";
                    pre.textContent = code;
                    content.appendChild(pre);
                }
            }
        };

        // Resizer Logic
        var resizer = doc.getElementById('resizer');
        var codePane = doc.getElementById('code-pane');
        var isResizing = false;

        resizer.addEventListener('mousedown', function (e) {
            isResizing = true;
            resizer.classList.add('active');
            doc.body.style.cursor = 'col-resize';
            e.preventDefault();
        });

        doc.addEventListener('mousemove', function (e) {
            if (!isResizing) return;
            var containerWidth = doc.body.clientWidth;
            var newWidth = containerWidth - e.clientX;
            if (newWidth < 200) newWidth = 200;
            if (newWidth > containerWidth - 200) newWidth = containerWidth - 200;
            codePane.style.width = newWidth + 'px';
        });

        doc.addEventListener('mouseup', function (e) {
            if (isResizing) {
                isResizing = false;
                resizer.classList.remove('active');
                doc.body.style.cursor = 'default';
            }
        });

        // Legend Toggle
        var btnLegend = doc.getElementById('btn-legend');
        var legendWin = doc.getElementById('legend-window');
        var btnCloseLegend = doc.getElementById('btn-close-legend');

        if (btnLegend && legendWin) {
            btnLegend.addEventListener('click', function () {
                var currentDisplay = win.getComputedStyle(legendWin).display;
                legendWin.style.display = (currentDisplay === 'none') ? 'block' : 'none';
            });
        }
        if (btnCloseLegend && legendWin) {
            btnCloseLegend.addEventListener('click', function () {
                legendWin.style.display = 'none';
            });
        }
    }

    // --- Rendering ---

    function renderSystemMap(data, win) {

        var doc = win.document;
        var container = doc.getElementById('graph-container');

        // Scope Variables
        var svg, gMain;
        var scale = 1, tx = 0, ty = 0;
        var isDragging = false, startX, startY;

        // Initial State: Isolated nodes collapsed
        var collapsedState = {};
        var sectionState = {}; // Track Params/Locals expansion per node
        var containerState = {}; // Track Pack/Logic/Global expansion

        for (var name in data.nodes) {
            var n = data.nodes[name];
            if (n.type === 'PROC' && n.degree === 0) {
                collapsedState[name] = true;
            }
            // Initialize Section State
            sectionState[name] = { params: true, locals: false, globals: false };
        }

        // Initialize Container State
        data.packs.forEach(p => {
            containerState[p.name] = { pack: false, logic: false, globals: false };
        });

        // Helper: Draw Orthogonal Path with Rounded Corners
        function drawOrthogonalPath(points, radius) {
            if (points.length < 2) return "";
            var d = `M ${points[0].x} ${points[0].y}`;

            for (var i = 1; i < points.length - 1; i++) {
                var p0 = points[i - 1];
                var p1 = points[i];
                var p2 = points[i + 1];

                var v1 = { x: p1.x - p0.x, y: p1.y - p0.y };
                var len1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y);
                var v2 = { x: p2.x - p1.x, y: p2.y - p1.y };
                var len2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y);
                var r = Math.min(radius, len1 / 2, len2 / 2);

                var startArc = { x: p1.x - (v1.x / len1) * r, y: p1.y - (v1.y / len1) * r };
                var endArc = { x: p1.x + (v2.x / len2) * r, y: p1.y + (v2.y / len2) * r };

                d += ` L ${startArc.x} ${startArc.y}`;
                d += ` Q ${p1.x} ${p1.y} ${endArc.x} ${endArc.y}`;
            }
            d += ` L ${points[points.length - 1].x} ${points[points.length - 1].y}`;
            return d;
        }

        // Helper: Find safe horizontal gap (Supports both Rank-based and Geometric scan)
        function findHorizontalGap(layout, targetY, startVal, endVal, currentPackName, minY, isGeometric, allowedTypes) {
            // 1. Collect obstacles
            var obstacles = [];
            for (var key in layout.nodes) {
                var n = layout.nodes[key];
                if (n.packName !== currentPackName) continue;
                if (allowedTypes && !allowedTypes.includes(n.type)) continue;

                var isHit = false;
                // Tuned Inflation: X=20 (Safe), Y=5 (Gap Friendly)
                var inflationX = 20;
                var inflationY = 5;

                if (isGeometric) {
                    // Geometric: Check X Overlap (Physical) + INFLATION
                    var minX = Math.min(startVal, endVal);
                    var maxX = Math.max(startVal, endVal);
                    if ((n.x - inflationX) < maxX && (n.x + n.w + inflationX) > minX) isHit = true;
                } else {
                    // Rank-based (Legacy/Columnar)
                    if (n.rank >= startVal && n.rank <= endVal) isHit = true;
                }

                if (isHit) {
                    obstacles.push({ y1: n.y - inflationY, y2: n.y + n.h + inflationY });
                }
            }
            // 1b. Sort Obstacles
            obstacles.sort((a, b) => a.y1 - b.y1);

            // 1c. Merge Overlapping Intervals (Fixes Expanded Card issues)
            var merged = [];
            if (obstacles.length > 0) {
                var current = { y1: obstacles[0].y1, y2: obstacles[0].y2 };
                for (var i = 1; i < obstacles.length; i++) {
                    var next = obstacles[i];
                    if (next.y1 < current.y2) { // Overlap found
                        current.y2 = Math.max(current.y2, next.y2); // Extend
                    } else {
                        merged.push(current);
                        current = { y1: next.y1, y2: next.y2 };
                    }
                }
                merged.push(current);
            }

            // 2. Find Gaps in MERGED intervals
            var gaps = [];
            var minGapSize = 10;
            for (var i = 0; i < merged.length - 1; i++) {
                var gapStart = merged[i].y2;
                var gapEnd = merged[i + 1].y1;
                if (gapEnd - gapStart >= minGapSize) {
                    var center = (gapStart + gapEnd) / 2;
                    if (minY === undefined || center >= minY) {
                        gaps.push({ start: gapStart, end: gapEnd, center: center });
                    }
                }
            }

            // 3. Find closest gap
            var closestGap = null;
            var minDist = Infinity;
            gaps.forEach(g => {
                var dist = Math.abs(g.center - targetY);
                if (dist < minDist) { minDist = dist; closestGap = g.center; }
            });

            if (closestGap !== null) return closestGap;

            // 4. Fallback (Outside)
            // Check against merged intervals for blocking
            var isBlocked = merged.some(o => targetY >= o.y1 && targetY <= o.y2);
            if (!isBlocked) {
                if (minY === undefined || targetY >= minY) return targetY;
            }

            if (merged.length > 0) {
                var topRoute = merged[0].y1 - 5;
                var bottomRoute = merged[merged.length - 1].y2 + 5;

                // Enforce minY on fallback choice
                if (minY !== undefined && topRoute < minY) {
                    return bottomRoute;
                }

                return (Math.abs(topRoute - targetY) < Math.abs(bottomRoute - targetY)) ? topRoute : bottomRoute;
            }
            return (minY !== undefined && targetY < minY) ? minY : targetY;
        }

        // Helper: Find maximum Right X (x + w) for nodes in a rank range
        // Used to prevent vertical path segments from cutting through wide nodes
        function findMaxRightX(layout, startRank, endRank, currentPackName) {
            var maxX = 0;
            // Normalize Ranks
            var r1 = Math.min(startRank, endRank);
            var r2 = Math.max(startRank, endRank);

            for (var key in layout.nodes) {
                var n = layout.nodes[key];
                // Check ALL node types (PROC, GLOBAL, etc) to ensure we route around them
                if (n.packName === currentPackName && n.rank >= r1 && n.rank <= r2) {
                    var rightEdge = n.x + n.w;
                    if (rightEdge > maxX) maxX = rightEdge;
                }
            }
            return maxX;
        }

        // Helper: Get vertical center of a section relative to node Y
        function getSectionCenterY(node, sectionName) {
            // CSS alignment constants matching getNodeHeight (35px base per section)
            var TITLE_H = 20;
            var ITEM_H = 14;
            var PAD_TOP = 5;
            var PAD_BOTTOM = 5;
            var MARGIN = 5;

            if (node.collapsed) return node.y + node.h / 2;

            var currentY = node.y + 35; // Start after Header

            var sState = sectionState[node.label.toUpperCase()];
            if (!sState) sState = { params: true, locals: false, globals: false };

            var nodeData = data.nodes[node.label.toUpperCase()];
            if (!nodeData) return node.y + node.h / 2;

            // Helper to process section
            function processSection(items, isExpanded, isTarget) {
                var h = 0;
                if (!items || items.length === 0) return { h: 0 };

                if (isExpanded) {
                    var listH = items.length * ITEM_H;
                    h = TITLE_H + PAD_TOP + listH + PAD_BOTTOM + MARGIN;
                    if (isTarget) {
                        // Target the center of the list
                        return { h: h, cy: currentY + TITLE_H + PAD_TOP + listH / 2 };
                    }
                } else {
                    h = 25; // 20 Title + 5 Margin (Collapsed)
                    if (isTarget) return { h: h, cy: currentY + h / 2 };
                }
                return { h: h };
            }

            // 1. Params
            var res = processSection(nodeData.params, sState.params, sectionName === 'params');
            if (res.cy !== undefined) return res.cy;
            currentY += res.h;

            // 2. Globals
            res = processSection(nodeData.globals, sState.globals, sectionName === 'globals');
            if (res.cy !== undefined) return res.cy;
            currentY += res.h;

            // 3. Locals
            res = processSection(nodeData.locals, sState.locals, sectionName === 'locals');
            if (res.cy !== undefined) return res.cy;
            currentY += res.h;

            return node.y + node.h / 2;
        }

        var layout = null;
        var selectedNodeName = null; // Track selection

        function showCode(nodeName) {
            selectedNodeName = nodeName;
            var node = data.nodes[nodeName];
            var codePane = doc.getElementById('code-pane');
            var codeContent = doc.getElementById('code-content');
            var codeHeader = doc.getElementById('code-header');

            if (codePane && codeContent && node && node.code) {
                codePane.style.display = 'flex'; // Ensure visible
                isCodePaneVisible = true;
                codeHeader.textContent = "Procedure: " + node.label;
                if (typeof SyntaxHighlighter !== 'undefined') {
                    codeContent.innerHTML = SyntaxHighlighter.highlight(node.code);
                } else {
                    codeContent.innerText = node.code;
                }

                // Ensure button state updates
                updateCodeButtonState();
            }
        }

        function draw() {
            try {

                container.innerHTML = ''; // Clear

                // Determine Collapsed State (Load from persistence if needed, here memory)
                // Recalculate Layout on every draw to reflect state changes
                layout = calculateLayout(data, collapsedState, sectionState, containerState);


                // SAFETY: Patch Ranks based on geometry (Fixes "Passing Under" issues)
                // Grid: StartX (40) + 30 (Pad) = 70. Stride: node 187 + gap 80 = 267.
                Object.values(layout.nodes).forEach(n => {
                    var geoRank = Math.round((n.x - 70) / 267);
                    if (geoRank < 0) geoRank = 0;
                    n.rank = geoRank;
                });

                if (layout.packs.length === 0) {
                    // console.error("Visualizer: NO PACKS IN LAYOUT!");
                    container.innerHTML = '<div style="padding:20px; color:red;">No Packs Found in Layout. Check Logs.</div>';
                    return;
                }

                // Adjust SVG size to fit content
                var maxX = 0, maxY = 0;
                layout.packs.forEach(p => {
                    if (isNaN(p.x) || isNaN(p.y) || isNaN(p.w) || isNaN(p.h)) {
                        // console.error("Visualizer: INVALID PACK GEOMETRY", p);
                    }
                    if (p.x + p.w > maxX) maxX = p.x + p.w;
                    if (p.y + p.h > maxY) maxY = p.y + p.h;
                });

                var svgNS = "http://www.w3.org/2000/svg";
                svg = doc.createElementNS(svgNS, "svg");
                svg.setAttribute("width", Math.max(maxX + 100, 2000));
                svg.setAttribute("height", Math.max(maxY + 100, 2000));

                var defs = doc.createElementNS(svgNS, "defs");
                // Define Markers for each color (Unrolled for safety)
                var marker = doc.createElementNS(svgNS, "marker");
                marker.setAttribute("id", "arrowhead");
                marker.setAttribute("markerWidth", "4");
                marker.setAttribute("markerHeight", "4");
                marker.setAttribute("refX", "4");
                marker.setAttribute("refY", "2");
                marker.setAttribute("orient", "auto");

                var p = doc.createElementNS(svgNS, "polygon");
                p.setAttribute("points", "0 0, 4 2, 0 4");
                p.setAttribute("fill", "#AAAAAA"); // Dimmed Grey Arrowhead
                marker.appendChild(p);
                defs.appendChild(marker);

                var filter = doc.createElementNS(svgNS, "filter");
                filter.setAttribute("id", "text-bg");
                filter.setAttribute("x", "-0.1");
                filter.setAttribute("y", "-0.1");
                filter.setAttribute("width", "1.2");
                filter.setAttribute("height", "1.2");
                var feFlood = doc.createElementNS(svgNS, "feFlood");
                feFlood.setAttribute("flood-color", "var(--bg-color)");
                feFlood.setAttribute("result", "bg");
                var feMerge = doc.createElementNS(svgNS, "feMerge");
                var feMergeNode1 = doc.createElementNS(svgNS, "feMergeNode");
                feMergeNode1.setAttribute("in", "bg");
                var feMergeNode2 = doc.createElementNS(svgNS, "feMergeNode");
                feMergeNode2.setAttribute("in", "SourceGraphic");
                feMerge.appendChild(feMergeNode1);
                feMerge.appendChild(feMergeNode2);

                filter.appendChild(feFlood);
                filter.appendChild(feMerge);
                defs.appendChild(filter);

                svg.appendChild(defs);

                gMain = doc.createElementNS(svgNS, "g");
                gMain.id = "main-group";
                svg.appendChild(gMain);

                // Helper to draw container
                function drawContainer(x, y, w, h, label, className, onToggle, isCollapsed) {
                    var g = doc.createElementNS(svgNS, "g");
                    g.setAttribute("class", className);

                    var rect = doc.createElementNS(svgNS, "rect");
                    rect.setAttribute("x", x);
                    rect.setAttribute("y", y);
                    rect.setAttribute("width", w);
                    rect.setAttribute("height", h);
                    rect.setAttribute("rx", "12"); // Explicit Rounded Corners
                    rect.setAttribute("ry", "12"); // Explicit Rounded Corners
                    rect.setAttribute("class", "container-rect");
                    g.appendChild(rect);

                    if (className === 'card-main' && typeof label === 'string' && !label.startsWith('Pack: ')) {
                        label = "Pack: " + label;
                    }

                    var headerH = 30;
                    if (!isCollapsed) {
                        var line = doc.createElementNS(svgNS, "line");
                        line.setAttribute("x1", x);
                        line.setAttribute("y1", y + headerH);
                        line.setAttribute("x2", x + w);
                        line.setAttribute("y2", y + headerH);
                        line.setAttribute("stroke", "var(--container-border)");
                        g.appendChild(line);
                    }

                    // Title Left (Adjusted 5% indent)
                    var text = doc.createElementNS(svgNS, "text");
                    text.setAttribute("x", x + (w * 0.05));
                    text.setAttribute("y", y + headerH / 2 + 1);
                    text.setAttribute("class", "container-title");
                    text.textContent = label;
                    g.appendChild(text);

                    // Min/Max Icon (Top Right)
                    var iconG = doc.createElementNS(svgNS, "g");
                    iconG.setAttribute("transform", `translate(${x + w - 25}, ${y + 5})`);
                    iconG.style.cursor = "pointer";
                    iconG.onclick = function (e) {
                        e.stopPropagation();
                        if (onToggle) onToggle();
                    };

                    var iconRect = doc.createElementNS(svgNS, "rect");
                    iconRect.setAttribute("width", "20");
                    iconRect.setAttribute("height", "20");
                    iconRect.setAttribute("fill", "transparent");
                    iconG.appendChild(iconRect);

                    var iconText = doc.createElementNS(svgNS, "text");
                    iconText.setAttribute("x", "10");
                    iconText.setAttribute("y", "15");
                    iconText.setAttribute("text-anchor", "middle");
                    iconText.setAttribute("fill", "var(--text-color)");
                    iconText.setAttribute("font-weight", "bold");
                    iconText.textContent = isCollapsed ? "+" : "-";
                    iconG.appendChild(iconText);

                    g.appendChild(iconG);
                    return g;
                }

                function toggleContainer(packName, type) {
                    if (containerState[packName]) {
                        containerState[packName][type] = !containerState[packName][type];
                        draw();
                    }
                }

                layout.packs.forEach(p => {
                    var g = drawContainer(p.x, p.y, p.w, p.h, p.label, "card-main", () => toggleContainer(p.packName, 'pack'), p.collapsed);
                    gMain.appendChild(g);
                    // If collapsed, we shouldn't render children. 
                    // But layout.innerCards/pools might still be there if we didn't filter them in calculateLayout.
                    // We did filter logic/globals content, but the containers themselves?
                    // In calculateLayout replacement above, I didn't fully implement removing them.
                    // Let's fix it here: if p.collapsed, don't render children.
                    // But the children are in layout.innerCards...
                    // We need to filter layout.innerCards based on pack state.
                });

                layout.innerCards.forEach(c => {
                    // Check if parent pack is collapsed
                    var packState = containerState[c.packName];
                    if (packState && packState.pack) return; // Don't render if pack collapsed

                    gMain.appendChild(drawContainer(c.x, c.y, c.w, c.h, c.label, "card-inner", () => toggleContainer(c.packName, 'logic'), c.collapsed));
                });

                layout.pools.forEach(p => {
                    var packState = containerState[p.packName];
                    if (packState && packState.pack) return;

                    var type = p.type; // 'globals' or 'data'
                    gMain.appendChild(drawContainer(p.x, p.y, p.w, p.h, p.label, p.type === 'data' ? "data-pool" : "global-pool", () => toggleContainer(p.packName, type), p.collapsed));
                });

                // Links
                var drawnLinks = {};
                data.links.forEach(function (link) {
                    var src = layout.nodes[link.from];
                    var dst = layout.nodes[link.to];
                    var linkId = link.from + "-" + link.to + "-" + link.type;



                    // Filter Implicit Links
                    if (link.type === 'GLOBAL_USAGE' && !showGlobalLinks) return;
                    if (link.type === 'ACCESS' && !showGlobalAccessLinks) return;
                    if (link.type === 'CALL' && !showProcedureLinks) return;

                    // Filter by Data Type (Granular per Link Type)
                    var dType = link.dataType || 'Float';
                    if (showDataTypes[link.type] && !showDataTypes[link.type][dType]) return;

                    if (src && dst && !drawnLinks[linkId]) {
                        // Visibility Check: Source or Dest Pack Collapsed?
                        if (src.packName && containerState[src.packName] && containerState[src.packName].pack) return;
                        if (dst.packName && containerState[dst.packName] && containerState[dst.packName].pack) return;

                        drawnLinks[linkId] = true;
                        var gLink = doc.createElementNS(svgNS, "g");
                        var path = doc.createElementNS(svgNS, "path");

                        // Tooltip (Robust)
                        var title = doc.createElementNS(svgNS, "title");
                        // Prioritize dedicated tooltip, fallback to debug string
                        title.textContent = link.tooltip ? link.tooltip : (link.from + " -> " + link.to + " (" + link.type + ")");
                        path.appendChild(title);

                        // 1. Calculate Anchors
                        var x1 = src.x + src.w;
                        var y1 = src.y + 20; // Default

                        // Precise Section Anchoring
                        if (link.type === 'CALL') {
                            y1 = getSectionCenterY(src, 'locals');
                        } else if (link.type === 'ACCESS') {
                            y1 = getSectionCenterY(src, 'globals');
                        }

                        var x2 = dst.x;
                        var y2 = dst.y + 16; // Center of Node Header (32px / 2 = 16)

                        if (link.type === 'ACCESS') y2 = dst.y + dst.h / 2; // Middle of Global Node

                        if (link.type === 'GLOBAL_USAGE') {
                            x1 = src.x + src.w; // Right of Global
                            y1 = src.y + (src.h / 2); // Middle of Global
                            x2 = dst.x; // Left of Procedure
                            y2 = dst.y + 16; // Header Center (Aligned with Procedure Links)
                        }

                        // 2. Routing Points
                        var points = [];
                        points.push({ x: x1, y: y1 }); // Start

                        if (link.type === 'CALL') {
                            var sRank = (typeof src.rank === 'number') ? src.rank : 0;
                            var dRank = (typeof dst.rank === 'number') ? dst.rank : 0;
                            var rankDiff = dRank - sRank;

                            // STRICT GRID ALIGNMENT
                            var gutterX = src.x + 227; // Center of gap to the RIGHT of Source (187w + 40gap)
                            var entryX = dst.x - 25;   // Left Entry Channel of Destination

                            if (rankDiff === 1) {
                                // 1. Direct neighbor: Source Right -> midX -> Entry Vertical -> Entry
                                // We use entryX as the vertical channel to ensure strict alignment.
                                // Logic: Src Right (x+187) -> Entry (dst.x-25).
                                // Dst.x = Src.x + 267. Entry = Src.x + 242.
                                // 187 -> 242 is valid forward movement.
                                points.push({ x: entryX, y: y1 });
                                points.push({ x: entryX, y: y2 });
                            } else {
                                // 2. Jump (Forward > 1) OR Loop (Backward <= 0)
                                // Strategy: Step Out -> Vertical Gutter -> Horizontal Scan -> Entry Vertical -> Entry

                                // A. Step Out to Source's Right Gutter
                                points.push({ x: gutterX, y: y1 });

                                // B. Find Safe Horizontal Level (Geometric Scan)
                                // Scan range: [min(Gutter, Entry), max(Gutter, Entry)]
                                var safeY = findHorizontalGap(layout, y1, gutterX, entryX, src.packName, y1 + 15, true, ['PROC']);

                                // C. Route via Safe Level
                                points.push({ x: gutterX, y: safeY });
                                points.push({ x: entryX, y: safeY });
                                points.push({ x: entryX, y: y2 });
                            }
                        } else if (link.type === 'ACCESS') {
                            // ACCESS (Global) - Left Entry Strategy
                            var logicCard = layout.innerCards.find(c => c.packName === src.packName && c.type === 'logic');
                            var globalPool = layout.pools.find(p => p.packName === src.packName);

                            // Determine Bus Y
                            var busY = y1 + 50;
                            if (logicCard && globalPool) {
                                busY = (logicCard.y + logicCard.h + globalPool.y) / 2;
                            }

                            var targetEntryX = x2 - 20;

                            points.push({ x: x1 + 15, y: y1 });      // Out
                            points.push({ x: x1 + 15, y: busY });    // Down to Bus
                            points.push({ x: targetEntryX, y: busY }); // Along Bus
                            points.push({ x: targetEntryX, y: y2 });   // Align Y

                            points.push({ x: x2, y: y2 });             // Enter
                        } else if (link.type === 'GLOBAL_USAGE') {
                            // Link: Global (Right) -> Procedure (Left)
                            // Route: Out Right -> Vertical -> Bus Left -> Vertical -> In Left

                            var logicCard = layout.innerCards.find(c => c.packName === src.packName && c.type === 'logic');
                            var globalPool = layout.pools.find(p => p.packName === src.packName);

                            // Determine Bus Y (Between Logic and Globals)
                            var busY = y1 - 40;
                            if (logicCard && globalPool) {
                                busY = (logicCard.y + logicCard.h + globalPool.y) / 2;
                            }

                            var leftGutterX = x2 - 25; // 25px into margin (Destination Entry Channel)
                            var stepOutX = x1 + 20;    // Step out to the RIGHT of the Global Node

                            points = [];
                            points.push({ x: x1, y: y1 });             // Start (Global Right Edge)
                            points.push({ x: stepOutX, y: y1 });       // 1. Exit Right (Clear Node)
                            points.push({ x: stepOutX, y: busY });     // 2. Vertical to Bus
                            points.push({ x: leftGutterX, y: busY });  // 3. Horizontal along Bus to Detination Gutter
                            points.push({ x: leftGutterX, y: y2 });    // 4. Vertical to Proc Y
                            points.push({ x: x2, y: y2 });             // 5. Enter Procedure from Left

                            // Filter duplicate points to prevent zero-length segments causing NaN in drawOrthogonalPath
                            points = points.filter(function (p, i, a) {
                                return i === 0 || !(Math.abs(p.x - a[i - 1].x) < 0.1 && Math.abs(p.y - a[i - 1].y) < 0.1);
                            });
                        }



                        if (link.type === 'CALL') {
                            points.push({ x: x2, y: y2 });
                        }

                        var d = drawOrthogonalPath(points, 10);

                        // Color Coding
                        var strokeColor = "var(--link-color)";

                        if (link.dataType === 'Integer') strokeColor = "#4CAF50";
                        else if (link.dataType === 'String') strokeColor = "#E040FB";
                        else strokeColor = "#FF9800";

                        path.setAttribute("class", "link " + link.type.toLowerCase());
                        path.style.stroke = strokeColor;
                        path.style.color = strokeColor; // For currentColor in drop-shadow
                        path.setAttribute("stroke-width", "1.5");
                        path.setAttribute("d", d);
                        path.setAttribute("fill", "none");
                        path.setAttribute("marker-end", "url(#arrowhead)");

                        // Hit Area
                        var pathHit = doc.createElementNS(svgNS, "path");
                        pathHit.setAttribute("d", d);
                        pathHit.setAttribute("stroke", "transparent");
                        pathHit.setAttribute("stroke-width", "10");
                        pathHit.setAttribute("fill", "none");
                        pathHit.style.cursor = "pointer";
                        var title = doc.createElementNS(svgNS, "title");
                        title.textContent = link.to + ":(" + (link.label || "") + ")";
                        pathHit.appendChild(title);

                        /* Interactive Highlight */
                        pathHit.addEventListener('click', function (e) {
                            e.stopPropagation();
                            // Toggle class on visible path
                            path.classList.add('highlighted');

                            // Remove after 2 seconds
                            if (path._timeout) clearTimeout(path._timeout);
                            path._timeout = setTimeout(function () {
                                path.classList.remove('highlighted');
                                path._timeout = null;
                            }, 2000);
                        });

                        gLink.appendChild(path);
                        gLink.appendChild(pathHit);
                        gMain.appendChild(gLink);
                    }
                });

                // Nodes
                // FIX: Z-Index sorting. Draw DATA_FILE before DATA_RECORD.
                // Draw Global/Procs mixed? Procedure with logic should be on top.
                // Simple sort: DATA_FILE (1), DATA_RECORD (2), Others (0)
                // Actually, render order: Default -> Data File -> Data Record.
                var nodeKeys = Object.keys(layout.nodes).sort((a, b) => {
                    var nA = layout.nodes[a];
                    var nB = layout.nodes[b];
                    // Priority: Data File < Data Record (Record on top)
                    var pA = nA.type === 'DATA_FILE' ? 1 : (nA.type === 'DATA_RECORD' ? 2 : 0);
                    var pB = nB.type === 'DATA_FILE' ? 1 : (nB.type === 'DATA_RECORD' ? 2 : 0);
                    return pA - pB;
                });

                nodeKeys.forEach(function (key) {
                    var n = layout.nodes[key];
                    // Visibility Check: Pack Collapsed
                    if (n.packName) {
                        var packState = containerState[n.packName];
                        if (packState && packState.pack) return;
                    }

                    var g = doc.createElementNS(svgNS, "g");
                    g.setAttribute("class", "node " + n.type.toLowerCase());
                    g.setAttribute("transform", `translate(${n.x}, ${n.y})`);

                    var fo = doc.createElementNS(svgNS, "foreignObject");
                    fo.setAttribute("width", n.w);
                    fo.setAttribute("height", n.h);

                    var div = doc.createElement("div");
                    var isEmpty = (!n.params || n.params.length === 0) && (!n.locals || n.locals.length === 0) && (!n.globals || n.globals.length === 0);
                    if (n.type === 'DATA_FILE') {
                        var fileNode = data.nodes[n.id]; // n is layout node, id matches map key
                        // Wait, n.id is UPPERCASE Name.
                        // data.nodes uses UPPERCASE Name.
                        var originalNode = data.nodes[n.label.toUpperCase()]; // label is name
                        // n.records ?
                        // calculateLayout populates records? No, extractSystemData does.
                        // layout.nodes copied it?
                        // Let's check calculateLayout.
                        // layout.nodes copies: params, locals, globals.
                        // It does NOT copy records explicitly in my previous edit?
                        // Wait, I added it to layout.nodes[dfName].records?
                        // No, I think I missed copying 'records' to layout node properties if I need to check length here.
                        // BUT, I can check data.nodes directly if I have the name.
                        isEmpty = (!data.nodes[n.label.toUpperCase()].records || data.nodes[n.label.toUpperCase()].records.length === 0);
                    }

                    div.className = "node-card " + (n.type === 'GLOBAL' ? 'global' : '') + (n.collapsed ? ' collapsed' : '') + (isEmpty ? ' empty' : '') + (n.type === 'DATA_FILE' ? ' data_file' : '') + (n.type === 'DATA_RECORD' ? ' data_record' : '');

                    var iconChar = n.collapsed ? '+' : '-';

                    // Determine Type Class
                    var typeClass = "type-float"; // Default
                    if (n.label.endsWith('%')) typeClass = "type-int";
                    else if (n.label.endsWith('$')) typeClass = "type-str";

                    var html = `<div class="node-header ${typeClass}">
                                <span class="node-title">${n.label}</span>
                                <span class="node-type">${n.type}</span>
                                <span class="node-icon">${iconChar}</span>
                            </div>`;

                    if (n.type === 'PROC' && !n.collapsed && !isEmpty) {
                        html += `<div class="node-body">`;

                        // Params Container
                        if (n.params && n.params.length > 0) {
                            var isExpanded = sectionState[n.label.toUpperCase()].params;
                            var displayStyle = isExpanded ? 'flex' : 'none';
                            var icon = isExpanded ? '&#9660;' : '&#9654;'; // Down or Right arrow

                            html += `<div class="inner-container">
                                    <div class="section-title section-toggle" data-node="${n.label.toUpperCase()}" data-section="params">
                                        ${icon} Params
                                    </div>
                                    <div class="section-list" style="display: ${displayStyle};">
                                        ${n.params.map(p => `<div class="item"><span style="font-weight:bold">${p.name}</span> <span style="opacity:0.7; font-size:90%">(${p.type})</span></div>`).join('')}
                                    </div>
                                 </div>`;
                        }

                        // Globals Container (First)
                        if (n.globals && n.globals.length > 0) {
                            var isExpanded = sectionState[n.label.toUpperCase()].globals;
                            var displayStyle = isExpanded ? 'flex' : 'none';
                            var icon = isExpanded ? '&#9660;' : '&#9654;';

                            html += `<div class="inner-container">
                                    <div class="section-title section-toggle" data-node="${n.label.toUpperCase()}" data-section="globals">
                                        ${icon} Globals (${n.globals.length})
                                    </div>
                                    <div class="section-list" style="display: ${displayStyle};">
                                        ${n.globals.map(g => {
                                var gNode = layout.nodes[g.toUpperCase()];
                                var lbl = gNode ? gNode.label : g;
                                return `<div class="item">${lbl}</div>`;
                            }).join('')}
                                    </div>
                                 </div>`;
                        }

                        // Locals Container (Second)
                        if (n.locals && n.locals.length > 0) {
                            var isExpanded = sectionState[n.label.toUpperCase()].locals;
                            var displayStyle = isExpanded ? 'flex' : 'none';
                            var icon = isExpanded ? '&#9660;' : '&#9654;';

                            html += `<div class="inner-container">
                                    <div class="section-title section-toggle" data-node="${n.label.toUpperCase()}" data-section="locals">
                                        ${icon} Locals (${n.locals.length})
                                    </div>
                                    <div class="section-list" style="display: ${displayStyle};">
                                        ${n.locals.map(l => `<div class="item">${l}</div>`).join('')}
                                    </div>
                                 </div>`;
                        }


                        html += `</div>`;
                    }

                    div.innerHTML = html;
                    fo.appendChild(div);
                    g.appendChild(fo);

                    // Click Logic: Separate PROC (Collapse/Select) vs Global (Select)
                    if (n.type === 'PROC') {
                        // Collapse Logic OR Select Logic
                        div.onclick = function (id, nodeData) {
                            return function (e) {
                                e.stopPropagation();
                                if (e.target.classList.contains('node-icon')) {
                                    // Collapse
                                    collapsedState[id] = !collapsedState[id];
                                    draw();
                                } else {
                                    // Select
                                    showCode(nodeData.label.toUpperCase());

                                    var allNodes = doc.querySelectorAll('.node-card');
                                    allNodes.forEach(el => el.classList.remove('active'));
                                    this.classList.add('active');
                                }
                            };
                        }(n.id, n);
                    } else if (n.type === 'DATA_FILE') {
                        // Data File Click Logic (Collapsible)
                        div.onclick = function (id, nodeData) {
                            return function (e) {
                                e.stopPropagation();
                                if (e.target.classList.contains('node-icon') || e.target.closest('.node-header')) {
                                    // Collapse
                                    collapsedState[id] = !collapsedState[id];
                                    draw();
                                }
                            };
                        }(n.id, n);
                    } else {
                        // Non-Interactive or Simple Select (Global, Record)
                        g.onclick = function (nodeData) {
                            return function (e) {
                                e.stopPropagation();
                                // Select
                                // showCode(nodeData.label.toUpperCase()); // No Code for Globals/Records really

                                var allNodes = doc.querySelectorAll('.node-card');
                                allNodes.forEach(el => el.classList.remove('active'));
                                this.querySelector('.node-card').classList.add('active');
                            };
                        }(n);
                    }

                    // Section Toggle Logic
                    var toggles = div.querySelectorAll('.section-toggle');
                    toggles.forEach(t => {
                        t.onclick = function (e) {
                            e.stopPropagation();
                            var nodeName = this.getAttribute('data-node');
                            var section = this.getAttribute('data-section');
                            sectionState[nodeName][section] = !sectionState[nodeName][section];
                            draw(); // Re-render
                        };
                    });

                    gMain.appendChild(g);
                });

                gMain.setAttribute("transform", `translate(${tx}, ${ty}) scale(${scale})`);

                container.appendChild(svg);

                // Attach SVG Listeners (Must be done every draw/re-creation)
                svg.addEventListener('mousedown', function (e) {
                    if (e.target.tagName === 'svg' || e.target.id === 'graph-container') {
                        isDragging = true;
                        startX = e.clientX - tx;
                        startY = e.clientY - ty;
                    }
                });

                svg.addEventListener('wheel', function (e) {
                    if (e.ctrlKey) {
                        e.preventDefault();
                        var s = Math.exp(-e.deltaY * 0.001);
                        scale *= s;
                        gMain.setAttribute("transform", `translate(${tx}, ${ty}) scale(${scale})`);
                    }
                });

            } catch (e) {
                // console.error("Visualizer: draw() CRASHED", e);
                container.innerHTML = `<div style="padding: 20px; color: red; font-family: monospace;">
                    <h3>Visualizer Error</h3>
                    <p>${e.message}</p>
                    <pre>${e.stack}</pre>
                </div>`;
            }
        }

        function updateTransform() {
            if (gMain) gMain.setAttribute("transform", `translate(${tx}, ${ty}) scale(${scale})`);
        }

        win.addEventListener('mousemove', function (e) {
            if (isDragging) {
                tx = e.clientX - startX;
                ty = e.clientY - startY;
                updateTransform();
            }
        });

        win.addEventListener('mouseup', function () {
            isDragging = false;
        });

        var btnLinks = doc.getElementById('btn-toggle-links');
        var btnAccess = doc.getElementById('btn-toggle-access');
        var btnCalls = doc.getElementById('btn-toggle-calls');

        // Default to TRUE if undefined
        var opt = OptionsManager.getOption('showGlobalUsageLinks');
        var showGlobalLinks = (opt === undefined || opt === null) ? true : opt;

        var optAccess = OptionsManager.getOption('showGlobalAccessLinks');
        var showGlobalAccessLinks = (optAccess === undefined || optAccess === null) ? true : optAccess;

        var optCalls = OptionsManager.getOption('showProcedureLinks');
        var showProcedureLinks = (optCalls === undefined || optCalls === null) ? true : optCalls;

        // Restore Code Button Logic
        var btnCode = doc.getElementById('btn-toggle-code');

        // Determine initial state based on global var or option (default hidden as per task)
        var codePane = doc.getElementById('code-pane');
        // Fix: style.display only reads inline styles. Default CSS is hidden.
        // We know it starts hidden, so initial state is false.
        var isCodePaneVisible = false;

        function updateCodeButtonState() {
            if (isCodePaneVisible) {
                btnCode.style.background = "var(--list-hover-bg)";
                btnCode.style.border = "1px solid var(--text-color)";
            } else {
                btnCode.style.background = "";
                btnCode.style.border = "";
            }
        }

        if (btnCode) {
            btnCode.onclick = function () {
                isCodePaneVisible = !isCodePaneVisible;
                if (codePane) {
                    codePane.style.display = isCodePaneVisible ? 'flex' : 'none';
                    // Layout might need adjustment if it overlays? No, it's absolute/sidebar.
                }
                updateCodeButtonState();
            };
            updateCodeButtonState();
        }

        function updateLinkButtons() {
            if (showGlobalLinks) {
                btnLinks.style.background = "var(--list-hover-bg)";
                btnLinks.style.border = "1px solid var(--text-color)";
            } else {
                btnLinks.style.background = "";
                btnLinks.style.border = "";
            }

            if (showGlobalAccessLinks) {
                btnAccess.style.background = "var(--list-hover-bg)";
                btnAccess.style.border = "1px solid var(--text-color)";
            } else {
                btnAccess.style.background = "";
                btnAccess.style.border = "";
            }

            if (showProcedureLinks) {
                btnCalls.style.background = "var(--list-hover-bg)";
                btnCalls.style.border = "1px solid var(--text-color)";
            } else {
                btnCalls.style.background = "";
                btnCalls.style.border = "";
            }
        }
        updateLinkButtons();

        btnLinks.onclick = function () {
            showGlobalLinks = !showGlobalLinks;
            OptionsManager.setOption('showGlobalUsageLinks', showGlobalLinks);
            updateLinkButtons();
            draw();
        };

        btnAccess.onclick = function () {
            showGlobalAccessLinks = !showGlobalAccessLinks;
            OptionsManager.setOption('showGlobalAccessLinks', showGlobalAccessLinks);
            updateLinkButtons();
            draw();
        };

        btnCalls.onclick = function () {
            showProcedureLinks = !showProcedureLinks;
            OptionsManager.setOption('showProcedureLinks', showProcedureLinks);
            updateLinkButtons();
            draw();
        };

        // Data Type Toggles (Nested)
        var showDataTypes = {
            GLOBAL_USAGE: { Integer: true, String: true, Float: true },
            ACCESS: { Integer: true, String: true, Float: true },
            CALL: { Integer: true, String: true, Float: true }
        };

        // Load Options
        var optTypes = OptionsManager.getOption('showDataTypesV2'); // V2 for structure change
        if (optTypes) showDataTypes = optTypes;

        function setupTypeToggle(id, category, type) {
            var chk = doc.getElementById(id);
            if (!chk) return;
            chk.checked = showDataTypes[category][type];
            chk.onchange = function () {
                showDataTypes[category][type] = chk.checked;
                OptionsManager.setOption('showDataTypesV2', showDataTypes);
                draw();
            };
        }

        // Setup Tabs
        var tabs = doc.querySelectorAll('.legend-tab');
        tabs.forEach(t => {
            t.onclick = function () {
                // Deactivate all
                tabs.forEach(tb => tb.classList.remove('active'));
                doc.querySelectorAll('.legend-panel').forEach(p => p.classList.remove('active'));

                // Activate clicked
                this.classList.add('active');
                var panelId = this.getAttribute('data-tab');
                doc.getElementById(panelId).classList.add('active');
            };
        });

        // Setup Checkboxes (Granular)
        setupTypeToggle('chk-usage-int', 'GLOBAL_USAGE', 'Integer');
        setupTypeToggle('chk-usage-str', 'GLOBAL_USAGE', 'String');
        setupTypeToggle('chk-usage-float', 'GLOBAL_USAGE', 'Float');

        setupTypeToggle('chk-access-int', 'ACCESS', 'Integer');
        setupTypeToggle('chk-access-str', 'ACCESS', 'String');
        setupTypeToggle('chk-access-float', 'ACCESS', 'Float');

        setupTypeToggle('chk-calls-int', 'CALL', 'Integer');
        setupTypeToggle('chk-calls-str', 'CALL', 'String');
        setupTypeToggle('chk-calls-float', 'CALL', 'Float');

        doc.getElementById('btn-zoom-in').onclick = function () { scale *= 1.2; updateTransform(); };
        doc.getElementById('btn-zoom-out').onclick = function () { scale /= 1.2; updateTransform(); };
        doc.getElementById('btn-fit').onclick = function () {
            scale = 1; tx = 0, ty = 0; updateTransform();
        };

        // Collapse/Expand All Logic
        var btnExpandAll = doc.getElementById('btn-expand-all');
        if (btnExpandAll) {
            btnExpandAll.onclick = function () {
                // Expand all Procedures
                Object.keys(data.nodes).forEach(function (key) {
                    if (data.nodes[key].type === 'PROC') {
                        collapsedState[key] = false;
                    }
                });
                draw();
            };
        }

        var btnCollapseAll = doc.getElementById('btn-collapse-all');
        if (btnCollapseAll) {
            btnCollapseAll.onclick = function () {
                // Collapse all Procedures
                Object.keys(data.nodes).forEach(function (key) {
                    if (data.nodes[key].type === 'PROC') {
                        collapsedState[key] = true;
                    }
                });
                draw();
            };
        }





        draw();
    }

    // --- Public API ---

    function showSystemMap(packs) {

        var data = extractSystemData(packs);
        lastData = data; // Store for re-rendering (handshake or reload)

        var win = openWindow();
        if (win) {
            // Check if window is already fully initialized (e.g. re-using open window)
            // We check for the container explicitly
            if (win.document && win.document.getElementById('graph-container')) {
                try {
                    renderSystemMap(data, win);
                } catch (e) {
                    // console.error("Visualizer: renderSystemMap Crashed", e);
                }
            } else {
                // 

                // Do nothing, wait for childWindowReady
            }
        } else {
            // console.error("Visualizer: Window FAILED to open");
        }
    }

    return {
        showSystemMap: showSystemMap,
        childWindowReady: function (win) {
            handleChildReady(win);
        },
        initChildEnvironment: initChildEnvironment
    };

})();
