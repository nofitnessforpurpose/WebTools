class SerialHandler{constructor(){this.port=null;this.reader=null;this.writer=null;this.encoder=new TextEncoder();this.decoder=new TextDecoder();this.lastYield=performance.now();this.keepReading=false;this.readLoopPromise=null;}async connect(){if(!navigator.serial){throw new Error('Web Serial API not supported in this browser.');}if(!this.port){this.port=await navigator.serial.requestPort();}if(this.port.readable)return;await this.port.open({baudRate:9600,dataBits:8,stopBits:1,parity:"none",flowControl:"none"});}async write(data){if(!this.port||!this.port.writable)return;const writer=this.port.writable.getWriter();await writer.write(data);writer.releaseLock();}async readLoop(callback){if(!this.port||!this.port.readable)return;this.keepReading=true;this.readLoopPromise=(async ()=>{while(this.port.readable&&this.keepReading){this.reader=this.port.readable.getReader();try{while(true){const{value,done}=await this.reader.read();if(done)break;if(value&&value.byteLength>0){if(performance.now()-this.lastYield>15){await new Promise(r=>setTimeout(r,0));this.lastYield=performance.now();}callback(value);}}}catch(error){console.warn('Serial Read Warning:',error);}finally{this.reader.releaseLock();}}})();await this.readLoopPromise;}async disconnect(forget=true){this.keepReading=false;if(this.reader){try{await this.reader.cancel();}catch(e){}}if(this.readLoopPromise){await this.readLoopPromise;this.readLoopPromise=null;}if(this.port){try{await this.port.close();}catch(e){console.warn("Port close warning:",e);}if(forget){this.port=null;}}}}